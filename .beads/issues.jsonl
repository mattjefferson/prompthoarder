{"id":"bd-135","title":"Test Prefix","status":"tombstone","priority":3,"issue_type":"task","created_at":"2026-01-22T03:11:11.696119Z","created_by":"mjefferson","updated_at":"2026-01-22T03:29:38.003700Z","deleted_at":"2026-01-22T03:29:38.003696Z","deleted_by":"mjefferson","delete_reason":"delete","original_type":"task","compaction_level":0,"original_size":0}
{"id":"pho-17i","title":"Create basic app shell","description":"# Create Basic App Shell\n\n## Overview\nCreate the minimal SwiftUI app entry point that launches and shows an empty window with a menu bar icon. This proves the project structure works end-to-end.\n\n## Why This Matters\nThis task validates that:\n- SPM structure is correct\n- Dependencies resolve and import\n- macOS app target produces runnable .app\n- Build + run cycle works\n- Menu bar integration works\n\n**If this doesn't work, nothing else will.**\n\n## Deliverables\n\n### PromptHoarderApp.swift\n```swift\nimport SwiftUI\n\n@main\nstruct PromptHoarderApp: App {\n    @State private var appState = AppState()\n    \n    var body: some Scene {\n        // Main window\n        WindowGroup {\n            ContentView()\n                .environment(appState)\n        }\n        \n        // Menu bar\n        MenuBarExtra(\"Prompt Hoarder\", systemImage: \"doc.text.magnifyingglass\") {\n            MenuBarView()\n                .environment(appState)\n        }\n        .menuBarExtraStyle(.window)\n        \n        // Settings\n        Settings {\n            SettingsView()\n                .environment(appState)\n        }\n    }\n}\n```\n\n### AppState.swift\n```swift\nimport SwiftUI\n\n@Observable\n@MainActor\nfinal class AppState {\n    // Placeholder for global state\n    var isLoading = false\n}\n```\n\n### ContentView.swift\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        Text(\"Prompt Hoarder\")\n            .frame(minWidth: 600, minHeight: 400)\n    }\n}\n```\n\n### MenuBarView.swift\n```swift\nimport SwiftUI\n\nstruct MenuBarView: View {\n    var body: some View {\n        VStack {\n            Text(\"Menu Bar Placeholder\")\n            Divider()\n            Button(\"Quit\") {\n                NSApplication.shared.terminate(nil)\n            }\n        }\n        .frame(width: 300)\n        .padding()\n    }\n}\n```\n\n### SettingsView.swift (placeholder)\n```swift\nimport SwiftUI\n\nstruct SettingsView: View {\n    var body: some View {\n        Text(\"Settings\")\n            .frame(width: 400, height: 200)\n    }\n}\n```\n\n## Technical Notes\n- Use `@Observable` (macOS 14+, not `ObservableObject`)\n- `MenuBarExtra` with `.menuBarExtraStyle(.window)` for popover behavior\n- Consider LSUIElement if hiding Dock icon (optional for MVP)\n\n## Acceptance Criteria\n- [ ] App launches without crash\n- [ ] Main window appears with placeholder content\n- [ ] Menu bar icon appears (system icon is fine)\n- [ ] Clicking menu bar icon shows popover\n- [ ] Cmd+Q quits the app cleanly\n- [ ] Cmd+, opens Settings window\n- [ ] App name shows correctly in menu bar\n\n## References\n- docs/plans/plan.md §6.4 View Hierarchy\n- Apple SwiftUI documentation for MenuBarExtra","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:17:21.659347Z","created_by":"mjefferson","updated_at":"2026-01-22T03:17:32.709041Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-17i","depends_on_id":"pho-1zt","type":"parent-child","created_at":"2026-01-22T03:17:21.659783Z","created_by":"mjefferson"},{"issue_id":"pho-17i","depends_on_id":"pho-2g1","type":"blocks","created_at":"2026-01-22T03:17:32.709030Z","created_by":"mjefferson"}]}
{"id":"pho-18f","title":"Build SettingsView","description":"# Build SettingsView\n\n## Overview\nSettings window with vault location, appearance, backup options.\n\n## Sections\n\n### General\n- Vault location (with change/migrate button)\n- Launch at login toggle\n- Show in Dock toggle\n\n### Appearance\n- Theme: System / Light / Dark\n- Font size (optional)\n\n### Backup\n- Enable auto-backup toggle\n- Backup location\n- Keep last N backups\n- Backup Now button\n\n### Advanced\n- Rebuild Index button\n- Export logs\n- Reset to defaults\n\n### About\n- Version info\n- Check for updates\n- Credits/acknowledgments\n\n## Implementation\n```swift\nstruct SettingsView: View {\n    var body: some View {\n        TabView {\n            GeneralSettingsView()\n                .tabItem { Label(\"General\", systemImage: \"gear\") }\n            \n            AppearanceSettingsView()\n                .tabItem { Label(\"Appearance\", systemImage: \"paintbrush\") }\n            \n            BackupSettingsView()\n                .tabItem { Label(\"Backup\", systemImage: \"externaldrive\") }\n            \n            AdvancedSettingsView()\n                .tabItem { Label(\"Advanced\", systemImage: \"wrench\") }\n        }\n        .frame(width: 450, height: 300)\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] All sections accessible\n- [ ] Vault location change works\n- [ ] Theme switching works\n- [ ] Backup toggle works\n- [ ] Rebuild Index works\n- [ ] Version info accurate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:27:15.045423Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:15.045795Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-18f","depends_on_id":"pho-xai","type":"parent-child","created_at":"2026-01-22T03:27:15.045785Z","created_by":"mjefferson"}]}
{"id":"pho-19j","title":"Implement VariableResolver","description":"# Implement VariableResolver\n\n## Overview\nParse and resolve `{{variable}}` placeholders in prompt content. This is used in editor preview, menu bar copy, and workflow runner.\n\n## Why This Matters\nVariables make prompts reusable:\n- `{{language}}` → \"Swift\", \"Python\", \"Rust\"\n- `{{context}}` → paste in relevant code\n- Users don't have to edit prompts for each use\n\n## Protocol Definition (From plan.md §5.5)\n```swift\nprotocol VariableResolving: Sendable {\n    func extractVariables(from content: String) -> [PromptVariable]\n    func resolve(content: String, values: [String: String]) -> String\n    func validate(content: String) -> [VariableWarning]\n}\n\nstruct PromptVariable: Identifiable, Equatable, Sendable {\n    let id: String           // Variable name\n    var defaultValue: String?\n}\n\nstruct VariableWarning: Sendable {\n    let range: Range<String.Index>\n    let message: String\n}\n```\n\n## Grammar Specification (From plan.md §5.5)\n\n### Token Form\n`{{ name }}` — whitespace allowed around name\n\n### Name Rules\nRegex: `[A-Za-z_][A-Za-z0-9_.-]*`\n- Must start with letter or underscore\n- Can contain letters, digits, underscore, dot, hyphen\n\n### Default Values\n`{{name=default value}}` — default runs until first `}}`\n\n### Escaping\n`\\{{` renders literal `{{`, does not start a token\n\n### Scope\nApply to Markdown body only (exclude YAML front matter)\n\n## Edge Cases (CRITICAL - Must Test All)\n\n| Input | Expected Output | Rationale |\n|-------|-----------------|-----------|\n| `{{name=has }} more}}` | Default = `has `, literal ` more}}` | First `}}` wins |\n| `{{outer={{inner}}}}` | Name = `outer={{inner` | First `}}` wins |\n| `{{}}` or `{{ }}` | Literal text | Invalid: empty name |\n| `{{name` | Literal text | Invalid: unclosed |\n| `{{name=}}` | Valid, empty default | Explicit empty |\n| `{{123name}}` | Literal text | Invalid: starts with digit |\n| `\\{{name}}` | Literal `{{name}}` | Escaped |\n| `{{name}} {{name}}` | Same variable twice | De-duplicated in extraction |\n\n## Implementation\n\n### Parser (Finite State Machine)\n```swift\nstruct VariableResolver: VariableResolving {\n    func extractVariables(from content: String) -> [PromptVariable] {\n        var variables: [String: PromptVariable] = [:]\n        var index = content.startIndex\n        \n        while index < content.endIndex {\n            // Check for escape\n            if content[index] == \"\\\\\" && \n               content.index(after: index) < content.endIndex &&\n               content[content.index(after: index)] == \"{\" {\n                index = content.index(index, offsetBy: 2)\n                continue\n            }\n            \n            // Check for opening {{\n            if content[index] == \"{\" && \n               content.index(after: index) < content.endIndex &&\n               content[content.index(after: index)] == \"{\" {\n                // Find closing }}\n                if let (name, defaultVal, endIdx) = parseVariable(content, from: index) {\n                    if !name.isEmpty && isValidName(name) {\n                        variables[name] = PromptVariable(id: name, defaultValue: defaultVal)\n                    }\n                    index = endIdx\n                    continue\n                }\n            }\n            \n            index = content.index(after: index)\n        }\n        \n        return Array(variables.values).sorted { $0.id < $1.id }\n    }\n    \n    func resolve(content: String, values: [String: String]) -> String {\n        var result = \"\"\n        var index = content.startIndex\n        \n        while index < content.endIndex {\n            // Handle escape\n            if content[index] == \"\\\\\" && ... {\n                result.append(contentsOf: content[...])  // Skip backslash, keep {{\n                continue\n            }\n            \n            // Handle variable\n            if content[index] == \"{\" && ... {\n                if let (name, defaultVal, endIdx) = parseVariable(...) {\n                    let value = values[name] ?? defaultVal ?? \"\"\n                    result.append(value)\n                    index = endIdx\n                    continue\n                }\n            }\n            \n            result.append(content[index])\n            index = content.index(after: index)\n        }\n        \n        return result\n    }\n    \n    func validate(content: String) -> [VariableWarning] {\n        // Find potential variables that are invalid\n        // Return warnings for debugging templates\n    }\n    \n    private func isValidName(_ name: String) -> Bool {\n        let pattern = \"^[A-Za-z_][A-Za-z0-9_.-]*$\"\n        return name.range(of: pattern, options: .regularExpression) != nil\n    }\n}\n```\n\n## Front Matter Exclusion\nVariables should NOT be resolved in YAML front matter:\n```swift\nfunc resolve(content: String, values: [String: String]) -> String {\n    // Split at front matter boundary\n    let (frontMatter, body) = splitFrontMatter(content)\n    \n    // Only resolve in body\n    let resolvedBody = resolveVariables(in: body, values: values)\n    \n    return frontMatter + resolvedBody\n}\n```\n\n## Testing Requirements\n**95%+ coverage required** — Edge cases are critical.\n\n```swift\n// Test every edge case from the table above\nfunc testFirstClosingBraceWins() async throws\nfunc testNestedBraces() async throws\nfunc testEmptyName() async throws\nfunc testUnclosed() async throws\nfunc testEmptyDefault() async throws\nfunc testInvalidNameStartsWithDigit() async throws\nfunc testEscaping() async throws\nfunc testDuplicateVariables() async throws\nfunc testFrontMatterExclusion() async throws\n```\n\n## Acceptance Criteria\n- [ ] extractVariables finds all valid variables\n- [ ] resolve substitutes values correctly\n- [ ] Default values used when no value provided\n- [ ] Empty default (\"\") used for {{name=}}\n- [ ] Invalid syntax treated as literal text\n- [ ] Escaping works (\\{{ → literal)\n- [ ] Front matter excluded from resolution\n- [ ] validate returns warnings for invalid tokens\n- [ ] 95%+ test coverage\n- [ ] All edge cases from table tested\n\n## References\n- docs/plans/plan.md §5.5 VariableResolver\n- docs/plans/plan.md Variable grammar specification","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:22:45.456531Z","created_by":"mjefferson","updated_at":"2026-01-22T03:22:45.456944Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-19j","depends_on_id":"pho-3sz","type":"parent-child","created_at":"2026-01-22T03:22:45.456934Z","created_by":"mjefferson"}]}
{"id":"pho-1c5","title":"Implement external edit handling","description":"# Implement External Edit Handling\n\n## Overview\nBuild the UI and logic for detecting and resolving conflicts when files are modified externally while open in the editor.\n\n## Why This Matters\nExternal edits are inevitable:\n- User opens file in VS Code for quick edit\n- Dropbox/iCloud syncs a change from another device\n- Git checkout modifies files\n\nWithout proper handling → silent data loss.\n\n## Two-Layer Detection (From plan.md §2.4)\n\n### Layer 1: Real-Time FileWatcher\nWhen file changes while open in editor:\n```swift\n// In PromptEditorViewModel\nfunc handleFileWatcherEvent(_ event: FileChangeEvent) {\n    switch event {\n    case .modified:\n        showBanner = true\n        bannerMessage = \"File changed on disk\"\n        bannerActions = [\n            BannerAction(\"Reload\") { await self.reloadFromDisk() },\n            BannerAction(\"Ignore\") { self.dismissBanner() }\n        ]\n        \n    case .deleted:\n        showDeletedAlert = true\n        // Options: Save as New File, Discard Changes\n        \n    case .renamed(let newURL):\n        // Update internal reference\n        currentFileURL = newURL\n    }\n}\n```\n\n### Layer 2: Save-Time Hash Check\nBefore any save, verify no external change:\n```swift\nfunc savePrompt() async throws {\n    // Check if file changed since we loaded it\n    let currentHash = try await vaultManager.computeHash(id: prompt.id)\n    \n    if currentHash != loadedHash {\n        // FSEvents missed it, show conflict dialog\n        showConflictDialog = true\n        return\n    }\n    \n    // Safe to save\n    try await promptStore.save(prompt)\n}\n```\n\n## UI Components\n\n### Banner (Non-Blocking)\nAppears at top of editor when file changes:\n```\n┌─────────────────────────────────────────────┐\n│ ⚠️ File changed on disk    [Reload] [Ignore] │\n└─────────────────────────────────────────────┘\n```\n\n### Conflict Dialog (Blocking)\nWhen save-time conflict detected:\n```\n┌─────────────────────────────────────────────┐\n│ Conflict Detected                            │\n├─────────────────────────────────────────────┤\n│ This file was modified outside the app.      │\n│                                             │\n│ Your version: \"Review the code for Swift...\" │\n│ Disk version: \"Review the code for Rust...\"  │\n│                                             │\n│ [Keep Mine] [Use Disk] [Duplicate as New]    │\n└─────────────────────────────────────────────┘\n```\n\n### Deleted File Alert\nWhen file deleted externally while open:\n```\n┌─────────────────────────────────────────────┐\n│ File Deleted                                 │\n├─────────────────────────────────────────────┤\n│ This file was deleted outside the app.       │\n│ You have unsaved changes.                    │\n│                                             │\n│ [Save as New File] [Discard Changes]         │\n└─────────────────────────────────────────────┘\n```\n\n## State Management\n\n```swift\n@Observable\nclass PromptEditorViewModel {\n    // Content state\n    var content: String = \"\"\n    var loadedHash: String = \"\"  // Hash at load time\n    var hasUnsavedChanges: Bool = false\n    \n    // Conflict state\n    var showExternalChangeBanner = false\n    var showConflictDialog = false\n    var showDeletedAlert = false\n    \n    // The conflict, if any\n    var conflict: ConflictState?\n    \n    struct ConflictState {\n        let yourContent: String\n        let diskContent: String\n        let diskHash: String\n    }\n    \n    func loadPrompt(_ prompt: Prompt) async {\n        content = prompt.content\n        loadedHash = try await vaultManager.computeHash(id: prompt.id)\n        hasUnsavedChanges = false\n        startFileWatcher()\n    }\n    \n    func resolveConflict(_ resolution: ConflictResolution) async throws {\n        switch resolution {\n        case .keepMine:\n            // Force save\n            try await promptStore.save(prompt, force: true)\n            loadedHash = await vaultManager.computeHash(id: prompt.id)\n            \n        case .useDisk:\n            // Reload\n            content = conflict!.diskContent\n            loadedHash = conflict!.diskHash\n            hasUnsavedChanges = false\n            \n        case .duplicateAsNew:\n            // Create copy\n            let newPrompt = prompt.duplicate()\n            try await promptStore.save(newPrompt)\n            // Navigate to new prompt\n        }\n        \n        conflict = nil\n        showConflictDialog = false\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Banner appears when file changes externally\n- [ ] Reload action loads disk version\n- [ ] Ignore action dismisses banner\n- [ ] Save-time conflict detection works\n- [ ] Conflict dialog shows both versions\n- [ ] Keep Mine overwrites disk\n- [ ] Use Disk discards in-memory changes\n- [ ] Duplicate as New creates copy with new UUID\n- [ ] Deleted file alert appears\n- [ ] UI tests for conflict flow\n\n## References\n- docs/plans/plan.md §2.4 External edits + conflicts\n- docs/plans/plan.md §5.4 FileWatcher","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:21:34.442460Z","created_by":"mjefferson","updated_at":"2026-01-22T03:21:45.341038Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-1c5","depends_on_id":"pho-2td","type":"blocks","created_at":"2026-01-22T03:21:45.325863Z","created_by":"mjefferson"},{"issue_id":"pho-1c5","depends_on_id":"pho-3n0","type":"parent-child","created_at":"2026-01-22T03:21:34.442852Z","created_by":"mjefferson"},{"issue_id":"pho-1c5","depends_on_id":"pho-tsy","type":"blocks","created_at":"2026-01-22T03:21:45.341027Z","created_by":"mjefferson"}]}
{"id":"pho-1nn","title":"Phase 1.6: Workflows (Basic)","description":"# Phase 1.6: Workflows (Basic)\n\n## Overview\nImplement basic workflow support: building ordered sequences of prompts and running them step-by-step with manual copy per step.\n\n## Why This Matters (Strategic Context)\nPower users often have multi-step AI processes:\n1. \"Context setting\" prompt (give the AI background)\n2. \"Main task\" prompt (the actual request)\n3. \"Review/refine\" prompt (improve the output)\n\nWithout workflows, users must:\n- Remember the sequence\n- Find each prompt manually\n- Copy-paste repeatedly\n- Track which step they're on\n\n**Workflows make multi-step processes repeatable and reliable.**\n\n## Key Trade-off: Manual vs Automated\n\n| Approach | Pros | Cons |\n|----------|------|------|\n| **Manual (MVP)** | No API keys, no costs, works with any AI | User does copy-paste |\n| Automated | Fully hands-off | API complexity, costs, rate limits |\n\n**We chose manual.** Dramatic simplicity gain. User still gets value from sequencing.\n\n## Key Components\n\n### WorkflowListView\n- List all workflows in sidebar section\n- Create/edit/delete actions\n- Workflow metadata (title, step count, tags)\n- Empty state for new users\n\n### WorkflowBuilderView\n- Add prompts to workflow (search/browse)\n- Drag-drop reordering of steps\n- Step notes editing (per-step context)\n- Variable override configuration\n- Remove step action\n\n### WorkflowRunnerView\n- Step-by-step execution UI\n- Current step highlighting\n- Prompt preview with variables resolved\n- Copy button per step\n- Next/Previous navigation\n- Progress indicator (step 2 of 5)\n\n## Data Model (From plan.md §4.1)\n\n### workflow_steps table\n```sql\nCREATE TABLE workflow_steps (\n    id TEXT PRIMARY KEY,\n    workflow_id TEXT NOT NULL,\n    prompt_id TEXT NOT NULL,\n    order_index INTEGER NOT NULL,  -- Gaps allowed (0, 5, 10)\n    step_notes TEXT,\n    variable_overrides TEXT,       -- JSON\n    FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE RESTRICT\n);\n```\n\n### Why order_index Allows Gaps\nDrag-drop reordering is simpler when you can insert between existing values:\n- Before: [0, 1, 2]\n- Insert between 0 and 1: [0, 0.5, 1, 2] → renumber to [0, 5, 10, 15]\n- No need to update every row on every drag\n\n### ON DELETE RESTRICT Explained\nIf a prompt is referenced by a workflow step, it CANNOT be hard-deleted.\n- User must first remove/replace the step\n- Or use Archive (soft delete) instead\n- UI shows which workflows would be affected\n\n## UX Requirements\n- Drag prompts from library to workflow builder\n- Drag to reorder steps within workflow\n- Runner remembers position on close (optional)\n- Variable values persist across steps (optional enhancement)\n\n## Testing Requirements\n- UI tests for build + run flow\n- Test prompt deletion blocked when referenced\n- Test variable override application\n- Test step reordering\n\n## This Epic Requires\n- Phase 1.2 Core Data Layer\n- Phase 1.3 Domain Services (WorkflowStore)\n- Phase 1.4 Main Window UI (PromptDetailView patterns)\n\n## References\n- docs/plans/plan.md §4.1 workflow_steps schema\n- docs/plans/plan.md §5.6 WorkflowStore","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-22T03:15:26.310516Z","created_by":"mjefferson","updated_at":"2026-01-22T03:15:38.353813Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-1nn","depends_on_id":"pho-1qw","type":"parent-child","created_at":"2026-01-22T03:15:26.310947Z","created_by":"mjefferson"},{"issue_id":"pho-1nn","depends_on_id":"pho-24o","type":"blocks","created_at":"2026-01-22T03:15:38.353802Z","created_by":"mjefferson"},{"issue_id":"pho-1nn","depends_on_id":"pho-3sz","type":"blocks","created_at":"2026-01-22T03:15:38.324933Z","created_by":"mjefferson"}]}
{"id":"pho-1nr","title":"Phase 1.7: Import/Export","description":"# Phase 1.7: Import/Export\n\n## Overview\nEnable users to import prompts from files and export their library for backup or migration.\n\n## Why This Matters (Strategic Context)\nSupports core design principles:\n- **Files are forever** — Users can always get their data out\n- **Portability** — Move between machines, share with others\n- **Rebuild-ability** — Import is how you restore after rebuild\n\nUse cases:\n- User has existing prompts in Markdown files\n- User wants to backup library before upgrade\n- User migrating from another system\n- User sharing a prompt collection\n\n## Import Features\n\n### Single File Import\n- Drag-drop or File > Import\n- Parse YAML front matter\n- Extract title, tags, category, ID\n- Generate UUID if missing\n\n### Bulk Folder Import\n- Select folder containing .md files\n- Progress indicator for large imports\n- Summary of results (imported, skipped, errors)\n\n### ID Conflict Resolution (From plan.md §2.4)\nWhen imported file has ID that already exists:\n\n**Single file dialog:**\n- **Import as Copy** (default): Generate new UUID\n- **Replace Existing**: Overwrite existing prompt\n- **Skip**: Don't import this file\n\n**Bulk import:**\n- Same options + \"Apply to all conflicts\" checkbox\n- Conflict count shown in dialog\n\n### Edge Case Handling\n| File Issue | Handling |\n|------------|----------|\n| Non-UTF8 encoding | Skip with warning |\n| File >1MB | Skip with warning |\n| Symlinks | Follow (or skip) |\n| Cloud placeholders | Skip |\n| Conflicted copies | Skip |\n| No front matter | Generate minimal metadata |\n| Malformed YAML | Attempt best-effort parse, log warning |\n\n## Export Features\n\n### Single Prompt Export\n- File > Export or context menu\n- Saves as .md with full front matter\n- Preserves all metadata\n\n### Full Library Export\nCreates .zip containing:\n```\nPromptHoarder-Export-2026-01-22/\n├── prompts/\n│   ├── code-review-assistant.md\n│   └── ...\n├── metadata.json      # Full metadata for reimport\n└── README.md          # Human-readable index\n```\n\n### Round-Trip Guarantee\nExport → Import should preserve:\n- All prompt content\n- All metadata (tags, categories, favorites)\n- Workflow definitions\n- Variable defaults\n\n## Technical Notes\n\n### File Permissions\n- Use NSOpenPanel for import (gets sandbox permissions)\n- Use NSSavePanel for export (same)\n- Store security-scoped bookmarks if needed\n\n### Progress Reporting\n- AsyncSequence or callback for progress\n- Cancelable operation\n- UI shows current file being processed\n\n### Atomic Writes\n- Export uses atomic write patterns\n- Temp file + rename\n- No partial exports left on disk\n\n## Testing Requirements\n- Test all ID conflict scenarios\n- Test round-trip (export → import) preserves data\n- Test malformed file handling\n- Test bulk import with 100+ files\n- Test cancel mid-import\n\n## This Epic Requires\n- Phase 1.2 Core Data Layer\n- Phase 1.3 Domain Services (ImportService, ExportService)\n\n## References\n- docs/plans/plan.md §2.4 Import ID conflict resolution\n- docs/plans/plan.md §9.2 Exported Library format","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-22T03:15:26.330643Z","created_by":"mjefferson","updated_at":"2026-01-22T03:15:38.339971Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-1nr","depends_on_id":"pho-1qw","type":"parent-child","created_at":"2026-01-22T03:15:26.330979Z","created_by":"mjefferson"},{"issue_id":"pho-1nr","depends_on_id":"pho-3sz","type":"blocks","created_at":"2026-01-22T03:15:38.339958Z","created_by":"mjefferson"}]}
{"id":"pho-1qw","title":"Phase 1: MVP Foundation","description":"# Phase 1: MVP Foundation\n\n## Executive Summary\nThis epic encompasses ALL work required to ship a functional MVP of Prompt Hoarder—a native macOS menu bar app for storing, finding, and reusing AI prompts.\n\n## Why This Project Exists (Vision Context)\nAI prompt users accumulate prompts across notes, documents, chat histories, and scattered files. Finding the right prompt at the right moment is slow. Reusing prompts consistently—especially parameterized ones—is tedious. Multi-step prompt sequences (\"workflows\") are nearly impossible to repeat reliably.\n\n**Prompt Hoarder exists to make prompt retrieval instant and prompt reuse frictionless.**\n\nThe core insight: prompts are a new kind of personal knowledge asset, deserving the same care we give to notes, bookmarks, or code snippets. But unlike those, prompts are *living documents*—frequently tweaked, parameterized, and chained together.\n\n## Design Principles (Must Guide All Decisions)\n1. **Speed above all** — Menu bar must return results faster than switching apps\n2. **Files are forever** — Markdown files, no proprietary format, no lock-in\n3. **Local-first, cloud-optional** — Everything works offline\n4. **Rebuild-ability** — SQLite index can be deleted and rebuilt from vault files\n5. **Progressive complexity** — Simple things instant, complex things available\n\n## Target User\n- Maintains 20-500 prompts (not 5, not 10,000)\n- Uses prompts across multiple AI tools (ChatGPT, Claude, Copilot, etc.)\n- Values tweaking and versioning prompts over time\n- May have multi-step processes they repeat regularly\n\nThis is NOT a prompt marketplace, sharing platform, or team tool. Personal productivity only.\n\n## MVP Success Criteria\n- User can create, edit, and organize prompts with tags/categories\n- Search returns results in <200ms for realistic library sizes\n- Menu bar popover provides instant access without context-switching\n- Variable resolution ({{placeholder}}) works inline in menu bar\n- Basic workflows allow multi-step prompt sequences\n- Import/export enables backup and migration\n- App is stable, performant, and ready for daily use\n\n## What MVP Explicitly Excludes (Deferred to Phase 2+)\n- **No paste injection** — Requires Accessibility permissions, complex UX\n- **No CLI** — Architecture supports it, but GUI must be solid first\n- **No sync** — Local-first is simpler, avoids conflict complexity\n- **No automation** — Manual workflow execution is sufficient\n\n## Architecture Summary\n- SwiftUI + MVVM (native macOS, testable)\n- SPM multi-target: PromptHoarderCore (shared) + PromptHoarder (app)\n- GRDB for SQLite with FTS5 search\n- Files + SQLite hybrid: files are source of truth, SQLite is derived index\n- Direct distribution + Sparkle updates\n\n## Sub-Epics (Implementation Order)\n1.1 Project Setup → 1.2 Core Data Layer → 1.3 Domain Services →\n1.4 Main Window UI ↔ 1.5 Menu Bar (parallel) →\n1.6 Workflows → 1.7 Import/Export → 1.8 Polish & Release\n\n## Key Trade-offs Made\n| We Chose | Over | Because |\n|----------|------|---------|\n| Clipboard copy (default) | Paste injection | Works everywhere, no permissions needed |\n| Local-only (MVP) | iCloud sync | Sync is complex, local-first is simpler |\n| Archive as default delete | Hard delete | Prompts in workflows can't vanish |\n| File wins on conflict | DB wins | Files are portable source of truth |\n\n## References\n- Full architecture: docs/plans/plan.md\n- This epic is the single container for all MVP work","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-22T03:12:03.680662Z","created_by":"mjefferson","updated_at":"2026-01-22T03:12:03.680662Z","compaction_level":0,"original_size":0}
{"id":"pho-1rs","title":"Build MenuBarPopover with search","description":"# Build MenuBarPopover with Search\n\n## Overview\nThe primary access point: a popover that appears from the menu bar with instant search.\n\n## Why This Matters\nThis is THE core feature. Users must be able to:\n1. Click menu bar icon (or hotkey in Phase 2)\n2. Start typing immediately\n3. See results in <200ms\n4. Press Enter to copy\n\nIf this flow isn't instant and frictionless, the app fails.\n\n## Implementation\n```swift\n@main\nstruct PromptHoarderApp: App {\n    @State private var appState = AppState()\n    \n    var body: some Scene {\n        MenuBarExtra(\"Prompt Hoarder\", systemImage: \"doc.text.magnifyingglass\") {\n            MenuBarPopoverView()\n                .environment(appState)\n        }\n        .menuBarExtraStyle(.window)\n        \n        // ... main window\n    }\n}\n\nstruct MenuBarPopoverView: View {\n    @Environment(MenuBarViewModel.self) private var viewModel\n    @FocusState private var searchFocused: Bool\n    \n    var body: some View {\n        VStack(spacing: 0) {\n            // Search field - auto-focused\n            TextField(\"Search prompts...\", text: $viewModel.searchQuery)\n                .textFieldStyle(.plain)\n                .font(.title3)\n                .padding()\n                .focused($searchFocused)\n            \n            Divider()\n            \n            // Tab bar\n            HStack {\n                TabButton(\"Favorites\", systemImage: \"star\", selected: viewModel.tab == .favorites) {\n                    viewModel.tab = .favorites\n                }\n                TabButton(\"Recent\", systemImage: \"clock\", selected: viewModel.tab == .recent) {\n                    viewModel.tab = .recent\n                }\n                TabButton(\"Workflows\", systemImage: \"arrow.triangle.branch\", selected: viewModel.tab == .workflows) {\n                    viewModel.tab = .workflows\n                }\n            }\n            .padding(.horizontal)\n            \n            Divider()\n            \n            // Results\n            QuickResultsListView(\n                results: viewModel.results,\n                selection: $viewModel.selectedIndex,\n                onSelect: viewModel.selectResult\n            )\n            \n            Divider()\n            \n            // Footer\n            HStack {\n                Button(\"Settings...\") { openSettings() }\n                Spacer()\n                Button(\"Open Library\") { openMainWindow() }\n            }\n            .padding(.horizontal)\n            .padding(.vertical, 8)\n        }\n        .frame(width: 350, height: 400)\n        .onAppear { searchFocused = true }\n    }\n}\n```\n\n## Keyboard Navigation\n```swift\nstruct QuickResultsListView: View {\n    let results: [PromptSummary]\n    @Binding var selection: Int\n    let onSelect: (PromptSummary) -> Void\n    \n    var body: some View {\n        ScrollViewReader { proxy in\n            List(Array(results.enumerated()), id: \\.element.id) { index, result in\n                ResultRowView(\n                    result: result,\n                    isSelected: index == selection\n                )\n                .id(index)\n                .onTapGesture { onSelect(result) }\n            }\n            .listStyle(.plain)\n            .onChange(of: selection) { _, newValue in\n                proxy.scrollTo(newValue, anchor: .center)\n            }\n        }\n        .onKeyPress(.upArrow) { selection = max(0, selection - 1); return .handled }\n        .onKeyPress(.downArrow) { selection = min(results.count - 1, selection + 1); return .handled }\n        .onKeyPress(.return) { if !results.isEmpty { onSelect(results[selection]) }; return .handled }\n    }\n}\n```\n\n## Performance Requirements\n- Popover appear: <100ms\n- Search to results: <200ms\n- No animation stutter\n\n## Focus Handling (Tricky)\nMenu bar popovers have notoriously tricky focus:\n- Search field must auto-focus on appear\n- Keyboard events must route correctly\n- Must work when app is not frontmost\n\nTest across macOS versions!\n\n## Acceptance Criteria\n- [ ] Popover appears on click\n- [ ] Search field auto-focuses\n- [ ] Typing immediately searches\n- [ ] Results appear in <200ms\n- [ ] Up/Down navigates results\n- [ ] Enter selects result\n- [ ] Escape closes popover\n- [ ] Tabs switch content\n- [ ] Footer buttons work","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:26:11.564336Z","created_by":"mjefferson","updated_at":"2026-01-22T03:26:11.564760Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-1rs","depends_on_id":"pho-30e","type":"parent-child","created_at":"2026-01-22T03:26:11.564748Z","created_by":"mjefferson"}]}
{"id":"pho-1u7","title":"Implement PromptStore","description":"# Implement PromptStore\n\n## Overview\nSQLite operations via GRDB: CRUD, FTS5 search, and coordinated file+DB mutations. The core data access layer.\n\n## Why This Matters\nPromptStore is the primary interface for all prompt data operations. It coordinates:\n- Database reads (fast, from SQLite)\n- Database writes (must sync with files)\n- Full-text search (FTS5)\n- Deletion protection (workflow references)\n\n## Protocol Definition (From plan.md §5.3)\n```swift\nprotocol PromptStoring: Sendable {\n    // List views—fast, DB-only queries\n    func fetchAllSummaries(includeArchived: Bool) async throws -> [PromptSummary]\n    func search(query: String, filters: SearchFilters) async throws -> [PromptSummary]\n    \n    // Detail/edit views—loads content from vault file\n    func fetch(id: UUID) async throws -> Prompt?\n    \n    // Mutations (coordinate file + DB)\n    func save(_ prompt: Prompt) async throws\n    func delete(id: UUID) async throws -> DeleteResult\n    func archive(id: UUID) async throws\n    func incrementUsage(id: UUID) async throws\n}\n\nenum DeleteResult {\n    case deleted\n    case blocked(referencingWorkflows: [WorkflowReference])\n}\n\nstruct WorkflowReference: Sendable {\n    let workflowId: UUID\n    let workflowTitle: String\n    let stepCount: Int\n}\n\nstruct SearchFilters {\n    var tags: [Tag]?\n    var category: Category?\n    var favoritesOnly: Bool\n    var includeArchived: Bool\n    var sortBy: SortOption\n}\n\nenum SortOption {\n    case updatedAt\n    case title\n    case usageCount\n}\n```\n\n## Implementation as Actor\n```swift\nactor PromptStore: PromptStoring {\n    private let dbQueue: DatabaseQueue\n    private let vaultManager: VaultManaging\n    \n    // MARK: - Read Operations (DB-only)\n    \n    func fetchAllSummaries(includeArchived: Bool) async throws -> [PromptSummary] {\n        try await dbQueue.read { db in\n            var query = PromptRecord\n                .including(all: PromptRecord.tags)\n                .including(optional: PromptRecord.category)\n            \n            if !includeArchived {\n                query = query.filter(Column(\"is_archived\") == false)\n            }\n            \n            return try query.fetchAll(db).map { $0.toSummary() }\n        }\n    }\n    \n    // MARK: - FTS5 Search\n    \n    func search(query: String, filters: SearchFilters) async throws -> [PromptSummary] {\n        try await dbQueue.read { db in\n            // FTS5 search\n            let pattern = FTS5Pattern(matchingAllPrefixesIn: query)\n            \n            let sql = \"\"\"\n                SELECT prompts.*\n                FROM prompts\n                JOIN prompts_fts ON prompts.sqlite_id = prompts_fts.rowid\n                WHERE prompts_fts MATCH ?\n                ORDER BY bm25(prompts_fts)\n            \"\"\"\n            \n            return try PromptRecord.fetchAll(db, sql: sql, arguments: [pattern])\n                .map { $0.toSummary() }\n        }\n    }\n    \n    // MARK: - Detail Fetch (DB + File)\n    \n    func fetch(id: UUID) async throws -> Prompt? {\n        // Get metadata from DB\n        guard let record = try await dbQueue.read({ db in\n            try PromptRecord.fetchOne(db, key: id.uuidString)\n        }) else {\n            return nil\n        }\n        \n        // Get content from file\n        let content = try await vaultManager.readPromptContent(id: id)\n        \n        return record.toPrompt(content: content)\n    }\n    \n    // MARK: - Save (File first, then DB)\n    \n    func save(_ prompt: Prompt) async throws {\n        // 1. Write file atomically\n        let fileContent = prompt.toMarkdownWithFrontMatter()\n        try await vaultManager.writePromptContent(id: prompt.id, content: fileContent)\n        \n        // 2. Update DB in transaction\n        let hash = SHA256.hash(data: Data(fileContent.utf8))\n        try await dbQueue.write { db in\n            var record = PromptRecord(from: prompt)\n            record.contentHash = hash.hexString\n            record.bodyCache = prompt.content.strippingMarkdown()\n            try record.save(db)\n        }\n    }\n    \n    // MARK: - Delete (Check references first)\n    \n    func delete(id: UUID) async throws -> DeleteResult {\n        // Check workflow references BEFORE deletion attempt\n        let references = try await checkWorkflowReferences(id: id)\n        \n        if !references.isEmpty {\n            return .blocked(referencingWorkflows: references)\n        }\n        \n        // Safe to delete: file first, then DB\n        try await vaultManager.deletePromptFile(id: id)\n        \n        try await dbQueue.write { db in\n            try PromptRecord.deleteOne(db, key: id.uuidString)\n        }\n        \n        return .deleted\n    }\n    \n    // MARK: - Archive (Soft delete)\n    \n    func archive(id: UUID) async throws {\n        // Update both file (front matter) and DB\n        guard var prompt = try await fetch(id: id) else { return }\n        prompt.isArchived = true\n        try await save(prompt)\n    }\n}\n```\n\n## Key Design Decisions\n\n### PromptSummary vs Prompt\n- **PromptSummary**: Lightweight, DB-only, for list views (no file I/O)\n- **Prompt**: Full content, requires file read, for detail/edit views\n\nThis prevents loading 500+ file contents into memory for a list view.\n\n### body_cache vs content\n- **body_cache**: Plain text extracted from Markdown, stored in DB for FTS\n- **content**: Full Markdown source, loaded from file on-demand\n\n### Deletion Protection\nAlways check `workflow_steps` for references before attempting delete:\n```swift\nfunc checkWorkflowReferences(id: UUID) async throws -> [WorkflowReference] {\n    try await dbQueue.read { db in\n        let sql = \"\"\"\n            SELECT w.id, w.title, COUNT(*) as step_count\n            FROM workflow_steps ws\n            JOIN workflows w ON ws.workflow_id = w.id\n            WHERE ws.prompt_id = ?\n            GROUP BY w.id\n        \"\"\"\n        // ...\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] fetchAllSummaries works (with/without archived)\n- [ ] FTS5 search returns ranked results\n- [ ] fetch loads file content on-demand\n- [ ] save writes file first, then DB\n- [ ] delete checks workflow references\n- [ ] archive updates both file and DB\n- [ ] incrementUsage updates usage_count and last_used_at\n- [ ] Unit tests for all operations\n- [ ] Performance: search <200ms for 5k prompts\n\n## References\n- docs/plans/plan.md §5.3 PromptStore\n- docs/plans/plan.md §4.3 Swift Models","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:20:10.138831Z","created_by":"mjefferson","updated_at":"2026-01-22T03:21:45.252301Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-1u7","depends_on_id":"pho-2wr","type":"blocks","created_at":"2026-01-22T03:21:45.252288Z","created_by":"mjefferson"},{"issue_id":"pho-1u7","depends_on_id":"pho-3n0","type":"parent-child","created_at":"2026-01-22T03:20:10.139317Z","created_by":"mjefferson"},{"issue_id":"pho-1u7","depends_on_id":"pho-kk1","type":"blocks","created_at":"2026-01-22T03:21:45.235833Z","created_by":"mjefferson"}]}
{"id":"pho-1w2","title":"Implement copy to clipboard action","description":"# Implement Copy to Clipboard Action\n\n## Overview\nThe final action: put the resolved prompt on the clipboard.\n\n## Implementation\n```swift\nfunc copyToClipboard(_ content: String) {\n    let pasteboard = NSPasteboard.general\n    pasteboard.clearContents()\n    pasteboard.setString(content, forType: .string)\n}\n```\n\n## With Usage Tracking\n```swift\nfunc copyPrompt(_ prompt: Prompt, resolved: String) async {\n    // Copy to clipboard\n    copyToClipboard(resolved)\n    \n    // Track usage\n    try? await promptStore.incrementUsage(id: prompt.id)\n    \n    // Close popover\n    closePopover()\n    \n    // Optional: visual feedback\n    showCopiedConfirmation = true\n}\n```\n\n## Visual Feedback Options\n1. **Toast/HUD**: Brief \"Copied!\" overlay\n2. **Sound**: System click sound\n3. **Menu bar icon change**: Brief checkmark\n4. **Nothing**: Just close (minimal)\n\nFor MVP: close popover immediately, maybe brief toast.\n\n## Error Handling\n```swift\nfunc copyPrompt(_ prompt: Prompt, resolved: String) async {\n    do {\n        copyToClipboard(resolved)\n        try await promptStore.incrementUsage(id: prompt.id)\n        closePopover()\n    } catch {\n        // Copy succeeded even if tracking failed\n        // Log error but don't show to user\n        logger.error(\"Failed to track usage: \\(error)\")\n        closePopover()\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Content copied to clipboard\n- [ ] Clipboard contains correct text\n- [ ] Usage count incremented\n- [ ] Popover closes after copy\n- [ ] Works when app is not frontmost\n- [ ] Error in tracking doesn't block copy","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:26:11.609991Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:26.727564Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-1w2","depends_on_id":"pho-30e","type":"parent-child","created_at":"2026-01-22T03:26:11.610399Z","created_by":"mjefferson"},{"issue_id":"pho-1w2","depends_on_id":"pho-3uf","type":"blocks","created_at":"2026-01-22T03:27:26.727551Z","created_by":"mjefferson"}]}
{"id":"pho-1zt","title":"Phase 1.1: Project Setup","description":"# Phase 1.1: Project Setup\n\n## Overview\nEstablish the foundational project structure, dependencies, and tooling. This MUST be completed before any other development work can begin.\n\n## Why This Matters (Strategic Context)\nA well-structured project from the start prevents painful refactoring later. The choices made here cascade through the entire codebase:\n\n1. **Multi-target SPM** enables clean separation between Core (shared logic) and App (GUI). This is essential because:\n   - Phase 2 adds a CLI that shares Core\n   - Core can be unit tested without launching the app\n   - Dependencies are isolated (Core has no UI deps)\n\n2. **Swift 6 strict concurrency from day 1** is critical because:\n   - Retrofitting concurrency safety later is extremely painful\n   - All our models need to be Sendable for async operations\n   - Data races are caught at compile time, not runtime\n\n3. **Tooling (SwiftLint/SwiftFormat)** establishes code quality baseline before any code exists\n\n## Technical Decisions (Rationale)\n\n### Why SPM (not Xcode project)\n- Clean dependency management (no Carthage, no CocoaPods)\n- Multi-target support is cleaner than xcodeproj gymnastics\n- Better for CI/CD (can build from CLI without Xcode)\n- Matches modern Swift conventions\n- Future CLI addition is trivial (just add target)\n\n### Why These Dependencies\n| Dependency | Why | Alternatives Rejected |\n|------------|-----|----------------------|\n| GRDB 7.0+ | Best Swift SQLite library, FTS5 native, migrations | Core Data (overkill), SQLite.swift (no FTS) |\n| swift-log 1.9+ | Structured logging, ecosystem standard | print() (no levels), OSLog (less portable) |\n| swift-markdown 0.5+ | Apple's own, guaranteed compatibility | cmark (C dep), custom (why reinvent) |\n| Sparkle 2.8+ | De facto macOS update standard | App Store (sandboxing), manual (bad UX) |\n\n### Why macOS 14+ Minimum\n- @Observable macro (cleaner than ObservableObject)\n- Improved NavigationSplitView stability\n- Better menu bar popover APIs\n- Cuts support burden; Sonoma+ is 90%+ of users by 2026\n\n## Deliverables\n1. Package.swift with multi-target structure\n2. Directory structure matching architecture\n3. All dependencies added and resolving\n4. Swift 6 strict concurrency enabled\n5. SwiftLint + SwiftFormat configured\n6. Basic app shell that launches\n\n## Success Criteria\n- `swift build` succeeds with zero warnings\n- `swift test` runs (even with empty tests)\n- App launches and shows empty window with menu bar icon\n- SwiftLint passes on all code\n\n## This Epic Blocks\n- ALL other Phase 1 work\n- Nothing can proceed until project structure is solid\n\n## References\n- docs/plans/plan.md §2.1 Module Structure\n- docs/plans/plan.md §3 Tech Stack","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-22T03:12:28.837072Z","created_by":"mjefferson","updated_at":"2026-01-22T03:12:28.837481Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-1zt","depends_on_id":"pho-1qw","type":"parent-child","created_at":"2026-01-22T03:12:28.837467Z","created_by":"mjefferson"}]}
{"id":"pho-22m","title":"Implement first-run onboarding","description":"# Implement First-Run Onboarding\n\n## Overview\nWelcome experience for new users: explain the app, set up vault location.\n\n## Screens\n\n### 1. Welcome\n- App logo/name\n- Brief tagline: \"Your AI prompts, instantly accessible\"\n- Get Started button\n\n### 2. Vault Location\n- Explain what the vault is\n- Default location shown\n- \"Use Default\" or \"Choose Custom\" buttons\n\n### 3. Quick Start (Optional)\n- Add sample prompts? (checkbox)\n- Brief feature highlights\n\n### 4. Ready\n- \"Open Prompt Hoarder\" button\n- Link to documentation (optional)\n\n## Detection\n```swift\n@AppStorage(\"hasCompletedOnboarding\") var hasCompletedOnboarding = false\n\nvar body: some Scene {\n    WindowGroup {\n        if hasCompletedOnboarding {\n            MainWindowView()\n        } else {\n            OnboardingView(onComplete: { hasCompletedOnboarding = true })\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Onboarding shows on first launch only\n- [ ] Vault location can be customized\n- [ ] Default location works\n- [ ] Sample prompts optional\n- [ ] Onboarding completion persisted","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-22T03:27:15.090547Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:15.090918Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-22m","depends_on_id":"pho-xai","type":"parent-child","created_at":"2026-01-22T03:27:15.090907Z","created_by":"mjefferson"}]}
{"id":"pho-24o","title":"Phase 1.4: Main Window UI","description":"# Phase 1.4: Main Window UI\n\n## Overview\nBuild the primary application window: library sidebar, prompt list, detail view, and editor. This is where users manage their prompt collection.\n\n## Why This Matters (Strategic Context)\nThe main window is where users spend time organizing and editing prompts. While the menu bar is for quick access, the main window is for:\n- Browsing and discovering prompts\n- Creating and editing content\n- Organizing with tags/categories\n- Building and managing workflows\n\n**Quality bar:** Standard macOS app feel. Users should find it familiar.\n\n## Architecture (MVVM)\n\n### View Layer (SwiftUI)\n```\nMainWindow/\n├── MainWindowView.swift      # NavigationSplitView shell\n├── SidebarView.swift         # Left panel: navigation\n├── PromptListView.swift      # Middle: prompt list\n├── PromptDetailView.swift    # Right: read-only view\n├── PromptEditorView.swift    # Edit mode\n└── MarkdownPreviewView.swift # Rendered preview\n```\n\n### ViewModel Layer (@Observable @MainActor)\n```\nViewModels/\n├── LibraryViewModel.swift      # List state, selection\n├── PromptDetailViewModel.swift # Single prompt state\n├── SearchViewModel.swift       # Search/filter state\n└── WorkflowViewModel.swift     # Workflow editing\n```\n\n## Key Views (From plan.md §6)\n\n### MainWindowView\n- NavigationSplitView with sidebar/content/detail\n- Window toolbar with search field\n- Keyboard navigation support\n- Window state persistence\n\n### SidebarView\nSections:\n- 📚 All Prompts\n- ⭐ Favorites\n- 📁 Categories (collapsible, expandable)\n- 🏷️ Tags (collapsible, expandable)\n- 🔄 Workflows\n- 🕐 Recent\n\n### PromptListView\n- Virtual list for performance (LazyVStack)\n- Sort options (date, title, usage)\n- Selection state management\n- Empty state handling\n\n### PromptDetailView (Read Mode)\n- Rendered Markdown (swift-markdown)\n- Metadata display (tags, category, dates)\n- Action buttons: Edit, Copy, Use\n- Variable highlighting ({{placeholders}})\n\n### PromptEditorView\n- Markdown text editing (TextEditor)\n- Live preview toggle\n- Tag picker, category picker\n- Variable highlighting in editor\n- Unsaved changes indicator\n\n### MarkdownPreviewView\n- Render using swift-markdown\n- Syntax highlighting for code blocks\n- Variable placeholder highlighting\n- Scroll sync with editor (stretch goal)\n\n## UX Requirements (Keyboard-First)\n| Shortcut | Action |\n|----------|--------|\n| Cmd+N | Create new prompt |\n| Cmd+F | Focus search field |\n| Cmd+Delete | Archive selected prompt |\n| Enter | Open selected prompt detail |\n| Escape | Close editor / cancel |\n| Cmd+S | Save current edit |\n| Cmd+, | Open Settings |\n\n## Testing Requirements\n- UI tests for main flows (create, edit, delete, search)\n- Accessibility audit (VoiceOver support)\n- Dark mode verification\n- Performance: list rendering <100ms for 500+ items\n\n## This Epic Can Parallel With\n- Phase 1.5 Menu Bar (both need Core + Services)\n\n## This Epic Requires\n- Phase 1.2 Core Data Layer\n- Phase 1.3 Domain Services\n\n## References\n- docs/plans/plan.md §6.1 Main Window wireframe\n- docs/plans/plan.md §6.4 View Hierarchy","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-22T03:14:20.711582Z","created_by":"mjefferson","updated_at":"2026-01-22T03:15:38.296649Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-24o","depends_on_id":"pho-1qw","type":"parent-child","created_at":"2026-01-22T03:14:20.711988Z","created_by":"mjefferson"},{"issue_id":"pho-24o","depends_on_id":"pho-3sz","type":"blocks","created_at":"2026-01-22T03:15:38.296635Z","created_by":"mjefferson"}]}
{"id":"pho-2a5","title":"Write domain services unit tests","description":"# Write Domain Services Unit Tests\n\n## Overview\nComprehensive tests for VariableResolver, TagStore, CategoryStore, WorkflowStore, ImportService, and ExportService.\n\n## Testing Requirements (From plan.md §8)\n- **VariableResolver**: 95%+ coverage (edge cases critical)\n- **WorkflowStore**: 90%+ coverage\n- **Import/Export**: 85%+ coverage\n\n## VariableResolverTests (95%+ Coverage Required)\n```swift\nfinal class VariableResolverTests: XCTestCase {\n    var resolver: VariableResolver!\n    \n    // Basic extraction\n    func testExtractSimpleVariable() throws\n    func testExtractMultipleVariables() throws\n    func testExtractVariableWithDefault() throws\n    func testExtractDeduplicates() throws\n    \n    // Edge cases (MUST test all from plan.md)\n    func testFirstClosingBraceWins() throws\n    func testNestedBracesFirstCloses() throws\n    func testEmptyNameTreatedAsLiteral() throws\n    func testUnclosedTreatedAsLiteral() throws\n    func testEmptyDefaultIsValid() throws\n    func testNameStartingWithDigitInvalid() throws\n    func testEscapingWorks() throws\n    \n    // Resolution\n    func testResolveWithValues() throws\n    func testResolveUsesDefault() throws\n    func testResolveEmptyDefaultToEmptyString() throws\n    func testResolveMissingValueNoDefault() throws\n    func testResolveFrontMatterExcluded() throws\n    \n    // Validation\n    func testValidateFindsInvalidTokens() throws\n    func testValidateReturnsWarningRange() throws\n}\n```\n\n## TagStoreTests\n```swift\nfinal class TagStoreTests: XCTestCase {\n    func testCreateTag() async throws\n    func testFindByNameCaseInsensitive() async throws\n    func testDuplicateNameRejected() async throws\n    func testFindOrCreateReturnsExisting() async throws\n    func testFindOrCreateCreatesNew() async throws\n    func testCleanupOrphansDeletesUnused() async throws\n    func testCleanupOrphansKeepsUsed() async throws\n}\n```\n\n## WorkflowStoreTests\n```swift\nfinal class WorkflowStoreTests: XCTestCase {\n    func testCreateWorkflow() async throws\n    func testFetchWithStepsOrdered() async throws\n    func testSaveUpdatesStepOrder() async throws\n    func testDeleteCascadesToSteps() async throws\n    func testWorkflowsReferencingPrompt() async throws\n    func testStepOrderIndexGapsAllowed() async throws\n    func testVariableOverridesStoredAsJSON() async throws\n}\n```\n\n## ImportServiceTests\n```swift\nfinal class ImportServiceTests: XCTestCase {\n    // Single file import\n    func testImportValidFile() async throws\n    func testImportGeneratesUUIDWhenMissing() async throws\n    func testImportRejectsNonUTF8() async throws\n    func testImportRejectsLargeFile() async throws\n    func testImportRejectsInvalidFormat() async throws\n    \n    // ID conflict\n    func testImportDetectsConflict() async throws\n    func testConflictResolutionImportAsCopy() async throws\n    func testConflictResolutionReplace() async throws\n    func testConflictResolutionSkip() async throws\n    \n    // Bulk import\n    func testBulkImportMultipleFiles() async throws\n    func testBulkImportCallsConflictHandler() async throws\n    func testBulkImportContinuesAfterError() async throws\n}\n```\n\n## ExportServiceTests\n```swift\nfinal class ExportServiceTests: XCTestCase {\n    func testExportSinglePrompt() async throws\n    func testExportLibraryStructure() async throws\n    func testExportMetadataAccurate() async throws\n    func testExportReadmeGenerated() async throws\n    func testExportWorkflowsAsJSON() async throws\n    func testExportProgressReported() async throws\n    func testRoundTripPreservesData() async throws\n}\n```\n\n## Test Fixtures\n```swift\nenum DomainTestFixtures {\n    static let promptWithVariables = \"\"\"\n    ---\n    id: 12345678-1234-1234-1234-123456789abc\n    title: Test Prompt\n    ---\n    \n    Hello {{name}}, you are using {{language=Swift}}.\n    \"\"\"\n    \n    static let workflow = Workflow(\n        id: UUID(),\n        title: \"Test Flow\",\n        description: nil,\n        tags: [],\n        steps: [\n            WorkflowStep(id: UUID(), promptId: UUID(), orderIndex: 0, stepNotes: nil, variableOverrides: [:])\n        ],\n        createdAt: Date(),\n        updatedAt: Date()\n    )\n}\n```\n\n## Coverage Verification\nRun coverage report and verify:\n```bash\nswift test --enable-code-coverage\nxcrun llvm-cov report .build/debug/PromptHoarderCoreTests.xctest/Contents/MacOS/PromptHoarderCoreTests\n```\n\n## Acceptance Criteria\n- [ ] VariableResolver: 95%+ coverage\n- [ ] All edge cases from plan.md tested\n- [ ] WorkflowStore: 90%+ coverage\n- [ ] Import/Export: 85%+ coverage\n- [ ] Round-trip test passes\n- [ ] Tests run in <10 seconds\n- [ ] No flaky tests\n\n## References\n- docs/plans/plan.md §8 Testing Strategy\n- docs/plans/plan.md §5.5 Variable edge cases","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:24:31.257996Z","created_by":"mjefferson","updated_at":"2026-01-22T03:24:41.397426Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-2a5","depends_on_id":"pho-19j","type":"blocks","created_at":"2026-01-22T03:24:41.333009Z","created_by":"mjefferson"},{"issue_id":"pho-2a5","depends_on_id":"pho-2s1","type":"blocks","created_at":"2026-01-22T03:24:41.397416Z","created_by":"mjefferson"},{"issue_id":"pho-2a5","depends_on_id":"pho-2vs","type":"blocks","created_at":"2026-01-22T03:24:41.348768Z","created_by":"mjefferson"},{"issue_id":"pho-2a5","depends_on_id":"pho-3bg","type":"blocks","created_at":"2026-01-22T03:24:41.382751Z","created_by":"mjefferson"},{"issue_id":"pho-2a5","depends_on_id":"pho-3sz","type":"parent-child","created_at":"2026-01-22T03:24:31.258361Z","created_by":"mjefferson"},{"issue_id":"pho-2a5","depends_on_id":"pho-8p4","type":"blocks","created_at":"2026-01-22T03:24:41.365278Z","created_by":"mjefferson"}]}
{"id":"pho-2cc","title":"Build Import UI with conflict dialog","description":"# Build Import UI with Conflict Dialog\n\n## Overview\nFile picker for import, progress indicator for bulk, conflict resolution dialog.\n\n## Key Components\n\n### File/Folder Picker\n```swift\nfunc importFiles() {\n    let panel = NSOpenPanel()\n    panel.canChooseFiles = true\n    panel.canChooseDirectories = true\n    panel.allowsMultipleSelection = true\n    panel.allowedContentTypes = [.init(filenameExtension: \"md\")!]\n    \n    if panel.runModal() == .OK {\n        Task {\n            await performImport(urls: panel.urls)\n        }\n    }\n}\n```\n\n### Conflict Dialog\n```swift\nstruct ImportConflictDialog: View {\n    let conflict: ImportConflict\n    let onResolve: (ConflictResolution) -> Void\n    @State private var applyToAll = false\n    \n    var body: some View {\n        VStack {\n            Text(\"Conflict Detected\")\n            Text(\"A prompt with this ID already exists.\")\n            // Show existing vs new\n            \n            Toggle(\"Apply to all conflicts\", isOn: $applyToAll)\n            \n            HStack {\n                Button(\"Import as Copy\") { onResolve(.importAsCopy) }\n                Button(\"Replace Existing\") { onResolve(.replaceExisting) }\n                Button(\"Skip\") { onResolve(.skip) }\n            }\n        }\n    }\n}\n```\n\n### Progress View\n```swift\nstruct ImportProgressView: View {\n    @Binding var progress: ImportProgress\n    \n    var body: some View {\n        VStack {\n            Text(\"Importing...\")\n            ProgressView(value: Double(progress.current), total: Double(progress.total))\n            Text(\"\\(progress.current) of \\(progress.total)\")\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] File picker opens\n- [ ] Folder selection works\n- [ ] Progress shown for bulk import\n- [ ] Conflict dialog appears when needed\n- [ ] Resolution options work\n- [ ] Apply to all checkbox works\n- [ ] Results summary shown","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:27:15.001909Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:15.002312Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-2cc","depends_on_id":"pho-1nr","type":"parent-child","created_at":"2026-01-22T03:27:15.002300Z","created_by":"mjefferson"}]}
{"id":"pho-2g1","title":"Configure Swift 6 strict concurrency","description":"# Configure Swift 6 Strict Concurrency\n\n## Overview\nEnable Swift 6 strict concurrency checking from day 1 to avoid painful migrations later.\n\n## Why This Matters (Critical)\n- **Swift 6 strict concurrency catches data races at compile time**\n- Enabling LATER means massive refactoring of all types\n- All our models must be Sendable anyway (for async/await)\n- Actors are the right pattern for shared state (PromptStore, VaultManager)\n\n**Cost of enabling later vs now: 10x more work.**\n\n## Configuration\n\n### Package.swift Settings\n```swift\ntargets: [\n    .target(\n        name: \"PromptHoarderCore\",\n        dependencies: [...],\n        swiftSettings: [\n            .swiftLanguageMode(.v6),\n            .enableExperimentalFeature(\"StrictConcurrency\"),\n        ]\n    ),\n    // Same for all targets\n]\n```\n\n### What This Means for Code\n\n#### Models (Structs)\nAll model types must be `Sendable`:\n```swift\nstruct Prompt: Identifiable, Codable, Equatable, Sendable {\n    let id: UUID\n    var title: String\n    // ...\n}\n```\n\n#### Services (Actors)\nShared mutable state uses actors:\n```swift\nactor PromptStore: PromptStoring {\n    private let db: DatabaseQueue\n    \n    func fetch(id: UUID) async throws -> Prompt? {\n        // Safe: actor isolation\n    }\n}\n```\n\n#### ViewModels (@MainActor)\nUI-bound state on main actor:\n```swift\n@Observable\n@MainActor\nfinal class LibraryViewModel {\n    var prompts: [PromptSummary] = []\n    // Safe: always on main thread\n}\n```\n\n#### Protocols\nService protocols must be `Sendable`:\n```swift\nprotocol PromptStoring: Sendable {\n    func fetch(id: UUID) async throws -> Prompt?\n}\n```\n\n## Patterns We'll Use Throughout\n| Type | Pattern |\n|------|---------|\n| Models | `struct` + `Sendable` |\n| Services | `actor` |\n| ViewModels | `@Observable @MainActor class` |\n| Background work | `Task { }` with proper isolation |\n\n## Acceptance Criteria\n- [ ] Build succeeds with zero concurrency warnings\n- [ ] All model types explicitly marked `Sendable`\n- [ ] Service protocols marked `Sendable`\n- [ ] Clean build output (no warnings)\n\n## References\n- docs/plans/plan.md §3 Tech Stack (Swift 6 strict concurrency)\n- Swift Evolution proposals for Sendable, actors","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:16:29.689066Z","created_by":"mjefferson","updated_at":"2026-01-22T03:17:32.696512Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-2g1","depends_on_id":"pho-1zt","type":"parent-child","created_at":"2026-01-22T03:16:29.689453Z","created_by":"mjefferson"},{"issue_id":"pho-2g1","depends_on_id":"pho-393","type":"blocks","created_at":"2026-01-22T03:17:32.696500Z","created_by":"mjefferson"}]}
{"id":"pho-2h3","title":"Performance verification and optimization","description":"# Performance Verification and Optimization\n\n## Overview\nVerify all performance targets are met, optimize if needed.\n\n## Performance Targets (From plan.md §8.3)\n| Operation | Target |\n|-----------|--------|\n| Search latency | <200ms |\n| App launch | <1s to menu bar ready |\n| Vault scan | <2s incremental |\n| List view render | <100ms |\n| Detail view open | <50ms |\n\n## Testing Methodology\n\n### 1. Create Test Dataset\n- Generate 500 prompts (typical)\n- Generate 5,000 prompts (stress test)\n- Include realistic content lengths\n\n### 2. Measure Each Operation\n```swift\nfunc measureSearch() async {\n    let start = CFAbsoluteTimeGetCurrent()\n    let _ = try await promptStore.search(query: \"swift code review\", filters: .default)\n    let elapsed = (CFAbsoluteTimeGetCurrent() - start) * 1000\n    print(\"Search: \\(elapsed)ms\")\n    XCTAssertLessThan(elapsed, 200)\n}\n```\n\n### 3. Profile with Instruments\n- Time Profiler for CPU hotspots\n- Allocations for memory usage\n- System Trace for disk I/O\n\n## Optimization Checklist\n- [ ] FTS5 query optimized (MATCH, not LIKE)\n- [ ] List uses PromptSummary (no file reads)\n- [ ] Debounced search (no query per keystroke)\n- [ ] Lazy loading where appropriate\n- [ ] No N+1 queries\n- [ ] Cached frequently accessed data\n\n## Acceptance Criteria\n- [ ] All performance targets met at 500 prompts\n- [ ] Search <500ms at 5,000 prompts\n- [ ] Memory usage <100MB typical\n- [ ] No UI freezes during operations\n- [ ] Performance documented","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:27:15.115389Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:26.820543Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-2h3","depends_on_id":"pho-18f","type":"blocks","created_at":"2026-01-22T03:27:26.785129Z","created_by":"mjefferson"},{"issue_id":"pho-2h3","depends_on_id":"pho-22m","type":"blocks","created_at":"2026-01-22T03:27:26.820532Z","created_by":"mjefferson"},{"issue_id":"pho-2h3","depends_on_id":"pho-xai","type":"parent-child","created_at":"2026-01-22T03:27:15.115831Z","created_by":"mjefferson"},{"issue_id":"pho-2h3","depends_on_id":"pho-xrf","type":"blocks","created_at":"2026-01-22T03:27:26.802302Z","created_by":"mjefferson"}]}
{"id":"pho-2s1","title":"Implement ExportService","description":"# Implement ExportService\n\n## Overview\nExport prompts as Markdown files and full library as ZIP archive.\n\n## Why This Matters\nUsers need to:\n- Share prompts with others\n- Create backups\n- Migrate to another system\n\nExport must preserve all metadata for round-trip.\n\n## Service Definition\n```swift\nprotocol ExportServiceProtocol: Sendable {\n    func exportPrompt(_ prompt: Prompt, to url: URL) async throws\n    func exportLibrary(to url: URL, progress: @escaping (ExportProgress) -> Void) async throws\n}\n\nstruct ExportProgress: Sendable {\n    let phase: ExportPhase\n    let current: Int\n    let total: Int\n}\n\nenum ExportPhase {\n    case preparingMetadata\n    case exportingPrompts\n    case creatingArchive\n    case complete\n}\n```\n\n## Single Prompt Export\n```swift\nfunc exportPrompt(_ prompt: Prompt, to url: URL) async throws {\n    let content = prompt.toMarkdownWithFrontMatter()\n    \n    // Atomic write\n    let tempURL = url.deletingLastPathComponent()\n        .appendingPathComponent(\".\\(UUID().uuidString).tmp\")\n    \n    try content.write(to: tempURL, atomically: true, encoding: .utf8)\n    \n    if FileManager.default.fileExists(atPath: url.path) {\n        try FileManager.default.replaceItemAt(url, withItemAt: tempURL)\n    } else {\n        try FileManager.default.moveItem(at: tempURL, to: url)\n    }\n}\n```\n\n## Full Library Export\nCreates ZIP with structure (From plan.md §9.2):\n```\nPromptHoarder-Export-2026-01-22/\n├── prompts/\n│   ├── code-review-assistant.md\n│   ├── api-documentation-gen.md\n│   └── ...\n├── workflows/\n│   └── workflows.json\n├── metadata.json\n└── README.md\n```\n\n### metadata.json\n```json\n{\n    \"version\": \"1.0\",\n    \"exportedAt\": \"2026-01-22T12:00:00Z\",\n    \"promptCount\": 42,\n    \"workflowCount\": 5,\n    \"tags\": [\"swift\", \"python\", \"code-review\"],\n    \"categories\": [\"Engineering\", \"Writing\"]\n}\n```\n\n### README.md\n```markdown\n# Prompt Hoarder Export\n\nExported: 2026-01-22 12:00 PM\n\n## Prompts (42)\n\n| Title | Tags | Category |\n|-------|------|----------|\n| Code Review Assistant | swift, code-review | Engineering |\n| API Documentation Gen | docs | Engineering |\n...\n\n## Workflows (5)\n\n| Title | Steps |\n|-------|-------|\n| Code Review Flow | 3 |\n...\n\n## How to Import\n\n1. Open Prompt Hoarder\n2. File > Import > Library\n3. Select this .zip file\n```\n\n### Implementation\n```swift\nfunc exportLibrary(to url: URL, progress: @escaping (ExportProgress) -> Void) async throws {\n    let tempDir = FileManager.default.temporaryDirectory\n        .appendingPathComponent(UUID().uuidString)\n    try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)\n    \n    defer {\n        try? FileManager.default.removeItem(at: tempDir)\n    }\n    \n    progress(ExportProgress(phase: .preparingMetadata, current: 0, total: 0))\n    \n    // Create directory structure\n    let promptsDir = tempDir.appendingPathComponent(\"prompts\")\n    let workflowsDir = tempDir.appendingPathComponent(\"workflows\")\n    try FileManager.default.createDirectory(at: promptsDir, withIntermediateDirectories: true)\n    try FileManager.default.createDirectory(at: workflowsDir, withIntermediateDirectories: true)\n    \n    // Export prompts\n    let prompts = try await promptStore.fetchAll()\n    progress(ExportProgress(phase: .exportingPrompts, current: 0, total: prompts.count))\n    \n    for (index, summary) in prompts.enumerated() {\n        let prompt = try await promptStore.fetch(id: summary.id)!\n        let filename = sanitizeFilename(prompt.title) + \".md\"\n        let fileURL = promptsDir.appendingPathComponent(filename)\n        try await exportPrompt(prompt, to: fileURL)\n        progress(ExportProgress(phase: .exportingPrompts, current: index + 1, total: prompts.count))\n    }\n    \n    // Export workflows\n    let workflows = try await workflowStore.fetchAll()\n    let workflowsJSON = try JSONEncoder().encode(workflows)\n    try workflowsJSON.write(to: workflowsDir.appendingPathComponent(\"workflows.json\"))\n    \n    // Create metadata\n    let metadata = ExportMetadata(\n        version: \"1.0\",\n        exportedAt: Date(),\n        promptCount: prompts.count,\n        workflowCount: workflows.count,\n        tags: Set(prompts.flatMap(\\.tags).map(\\.name)).sorted(),\n        categories: Set(prompts.compactMap(\\.category?.name)).sorted()\n    )\n    try JSONEncoder().encode(metadata).write(to: tempDir.appendingPathComponent(\"metadata.json\"))\n    \n    // Create README\n    let readme = generateReadme(prompts: prompts, workflows: workflows)\n    try readme.write(to: tempDir.appendingPathComponent(\"README.md\"), atomically: true, encoding: .utf8)\n    \n    // Create ZIP\n    progress(ExportProgress(phase: .creatingArchive, current: 0, total: 1))\n    try createZip(from: tempDir, to: url)\n    \n    progress(ExportProgress(phase: .complete, current: 1, total: 1))\n}\n```\n\n## File Naming\nSanitize titles for filesystem:\n```swift\nfunc sanitizeFilename(_ title: String) -> String {\n    let invalid = CharacterSet(charactersIn: \":/\\\\?*\\\"<>|\")\n    return title\n        .components(separatedBy: invalid)\n        .joined(separator: \"-\")\n        .prefix(50)  // Reasonable length limit\n        .trimmingCharacters(in: .whitespaces)\n}\n```\n\n## Acceptance Criteria\n- [ ] Single prompt export works\n- [ ] Full library export creates correct structure\n- [ ] metadata.json contains accurate data\n- [ ] README.md is human-readable\n- [ ] Workflows exported as JSON\n- [ ] Progress reported during export\n- [ ] Atomic writes prevent corruption\n- [ ] ZIP creation works\n- [ ] Round-trip: export → import preserves all data\n- [ ] Unit tests for export\n\n## References\n- docs/plans/plan.md §9.2 Exported Library format","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:24:31.236374Z","created_by":"mjefferson","updated_at":"2026-01-22T03:24:41.316250Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-2s1","depends_on_id":"pho-3sz","type":"parent-child","created_at":"2026-01-22T03:24:31.236773Z","created_by":"mjefferson"},{"issue_id":"pho-2s1","depends_on_id":"pho-8p4","type":"blocks","created_at":"2026-01-22T03:24:41.316237Z","created_by":"mjefferson"}]}
{"id":"pho-2td","title":"Implement file-DB sync logic","description":"# Implement File-DB Sync Logic\n\n## Overview\nCoordinate the synchronization between vault files (source of truth) and SQLite database (derived index). Handle all sync scenarios: new files, modified files, deleted files, conflicts.\n\n## Why This Matters\nThe hybrid storage model requires careful coordination:\n- Files can change externally (user edits, sync tools)\n- DB must always reflect current file state\n- On conflict, file wins (after user confirmation)\n- Rebuild must restore DB from files exactly\n\n## Sync Scenarios\n\n### 1. App Launch Sync\nOn every app launch:\n```swift\nfunc performLaunchSync() async throws {\n    let scanResult = try await vaultManager.scanVault()\n    \n    // Handle new files (external additions)\n    for url in scanResult.newFiles {\n        let prompt = try parsePromptFile(url)\n        try await promptStore.insert(prompt)\n    }\n    \n    // Handle modified files (external edits)\n    for url in scanResult.modifiedFiles {\n        let prompt = try parsePromptFile(url)\n        try await promptStore.update(prompt)\n    }\n    \n    // Handle deleted files (external deletions)\n    for id in scanResult.deletedIds {\n        try await promptStore.removeFromIndex(id: id)\n    }\n}\n```\n\n### 2. Save Operation (App → File → DB)\n```swift\nfunc savePrompt(_ prompt: Prompt) async throws {\n    // 1. Compute new content hash\n    let content = prompt.toMarkdownWithFrontMatter()\n    let newHash = SHA256.hash(data: Data(content.utf8)).hexString\n    \n    // 2. Check for external change (conflict detection)\n    let currentFileHash = try await vaultManager.computeHash(id: prompt.id)\n    let dbHash = try await promptStore.getContentHash(id: prompt.id)\n    \n    if currentFileHash != dbHash {\n        // File changed externally while we had it open!\n        throw SyncError.externalChangeDetected(\n            fileHash: currentFileHash,\n            expectedHash: dbHash\n        )\n    }\n    \n    // 3. Write file atomically\n    try await vaultManager.writePromptContent(id: prompt.id, content: content)\n    \n    // 4. Update DB with new hash\n    try await promptStore.save(prompt, contentHash: newHash)\n}\n```\n\n### 3. Conflict Resolution\nWhen external change detected:\n```swift\nenum ConflictResolution {\n    case keepMine      // Overwrite file with in-memory version\n    case useDisk       // Discard in-memory, reload from file\n    case duplicateAsNew // Create new prompt with in-memory content\n}\n\nfunc resolveConflict(\n    prompt: Prompt,\n    resolution: ConflictResolution\n) async throws -> Prompt {\n    switch resolution {\n    case .keepMine:\n        // Force save, ignoring external change\n        try await vaultManager.writePromptContent(\n            id: prompt.id,\n            content: prompt.toMarkdownWithFrontMatter()\n        )\n        try await promptStore.save(prompt)\n        return prompt\n        \n    case .useDisk:\n        // Reload from file\n        return try await promptStore.fetch(id: prompt.id)!\n        \n    case .duplicateAsNew:\n        // Create new prompt with different UUID\n        var newPrompt = prompt\n        newPrompt.id = UUID()\n        newPrompt.title = \"\\(prompt.title) (Copy)\"\n        try await promptStore.save(newPrompt)\n        return newPrompt\n    }\n}\n```\n\n### 4. Rebuild Sync (Full Reset)\nWhen user triggers \"Rebuild Index\":\n```swift\nfunc rebuildSync(progress: (RebuildProgress) -> Void) async throws {\n    progress(.deletingOldDatabase)\n    try await databaseManager.close()\n    try FileManager.default.removeItem(at: dbPath)\n    \n    progress(.creatingSchema)\n    try await databaseManager.initialize()\n    \n    progress(.scanningVault)\n    let allFiles = try await vaultManager.enumerateAllMarkdownFiles()\n    \n    progress(.indexingFiles)\n    for (index, url) in allFiles.enumerated() {\n        let prompt = try parsePromptFile(url)\n        try await promptStore.insert(prompt)\n        progress(.indexingFiles(current: index + 1, total: allFiles.count))\n    }\n    \n    progress(.rebuildingFTS)\n    try await promptStore.rebuildFTSIndex()\n    \n    progress(.complete)\n}\n```\n\n## Content Hashing\n```swift\nextension SHA256Digest {\n    var hexString: String {\n        self.map { String(format: \"%02x\", $0) }.joined()\n    }\n}\n\nfunc computeContentHash(content: String) -> String {\n    let data = Data(content.utf8)\n    return SHA256.hash(data: data).hexString\n}\n```\n\n## Error Types\n```swift\nenum SyncError: Error {\n    case externalChangeDetected(fileHash: String, expectedHash: String)\n    case fileNotFound(id: UUID)\n    case parseFailed(url: URL, reason: String)\n    case conflictUnresolved\n}\n```\n\n## Invariants to Maintain\n1. **File is always source of truth** — On any discrepancy, trust file\n2. **DB is rebuildable** — Can always delete DB and rebuild from files\n3. **No silent data loss** — Always surface conflicts to user\n4. **Hash verification** — Before save, verify no external change\n\n## Acceptance Criteria\n- [ ] Launch sync detects new/modified/deleted files\n- [ ] Save operation writes file before DB\n- [ ] External change detection works\n- [ ] Conflict resolution UI integrated\n- [ ] Rebuild sync restores full index\n- [ ] Content hashing is consistent\n- [ ] Unit tests for all sync scenarios\n- [ ] Integration test for conflict flow\n\n## References\n- docs/plans/plan.md §2.4 Source of truth, Atomicity\n- docs/plans/plan.md §2.4 External edits + conflicts","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:21:34.421631Z","created_by":"mjefferson","updated_at":"2026-01-22T03:21:45.311390Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-2td","depends_on_id":"pho-1u7","type":"blocks","created_at":"2026-01-22T03:21:45.283625Z","created_by":"mjefferson"},{"issue_id":"pho-2td","depends_on_id":"pho-3km","type":"blocks","created_at":"2026-01-22T03:21:45.297546Z","created_by":"mjefferson"},{"issue_id":"pho-2td","depends_on_id":"pho-3n0","type":"parent-child","created_at":"2026-01-22T03:21:34.422022Z","created_by":"mjefferson"},{"issue_id":"pho-2td","depends_on_id":"pho-tsy","type":"blocks","created_at":"2026-01-22T03:21:45.311379Z","created_by":"mjefferson"}]}
{"id":"pho-2vd","title":"Build MainWindowView shell with NavigationSplitView","description":"# Build MainWindowView Shell\n\n## Overview\nCreate the main app window using NavigationSplitView with sidebar/content/detail columns.\n\n## Why This Matters\nNavigationSplitView is the standard macOS pattern for master-detail interfaces. Getting the shell right establishes the foundation for all other main window views.\n\n## Implementation\n```swift\nstruct MainWindowView: View {\n    @State private var selectedSection: SidebarSection? = .allPrompts\n    @State private var selectedPromptId: UUID?\n    @Environment(AppState.self) private var appState\n    \n    var body: some View {\n        NavigationSplitView {\n            SidebarView(selection: $selectedSection)\n        } content: {\n            PromptListView(\n                section: selectedSection,\n                selection: $selectedPromptId\n            )\n        } detail: {\n            if let promptId = selectedPromptId {\n                PromptDetailView(promptId: promptId)\n            } else {\n                ContentUnavailableView(\n                    \"Select a Prompt\",\n                    systemImage: \"doc.text\"\n                )\n            }\n        }\n        .frame(minWidth: 800, minHeight: 500)\n        .toolbar {\n            ToolbarItem(placement: .navigation) {\n                Button(action: toggleSidebar) {\n                    Image(systemName: \"sidebar.left\")\n                }\n            }\n            ToolbarItem {\n                SearchField()\n            }\n            ToolbarItem {\n                Button(action: createPrompt) {\n                    Image(systemName: \"plus\")\n                }\n            }\n        }\n    }\n}\n```\n\n## Sidebar Sections\n```swift\nenum SidebarSection: Hashable {\n    case allPrompts\n    case favorites\n    case recent\n    case category(Category)\n    case tag(Tag)\n    case workflows\n}\n```\n\n## Window Configuration\n- Minimum size: 800x500\n- Default size: 1000x700\n- Resizable with proper column proportions\n- State persistence (remember size/position)\n\n## Keyboard Shortcuts\n| Shortcut | Action |\n|----------|--------|\n| Cmd+N | New prompt |\n| Cmd+F | Focus search |\n| Cmd+1 | All Prompts |\n| Cmd+2 | Favorites |\n\n## Acceptance Criteria\n- [ ] NavigationSplitView renders correctly\n- [ ] Sidebar shows sections\n- [ ] Content shows prompt list\n- [ ] Detail shows selected prompt (or empty state)\n- [ ] Toolbar with search and add button\n- [ ] Window resizing works properly\n- [ ] Keyboard shortcuts work","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:26:11.470920Z","created_by":"mjefferson","updated_at":"2026-01-22T03:26:11.471350Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-2vd","depends_on_id":"pho-24o","type":"parent-child","created_at":"2026-01-22T03:26:11.471338Z","created_by":"mjefferson"}]}
{"id":"pho-2vs","title":"Implement TagStore and CategoryStore","description":"# Implement TagStore and CategoryStore\n\n## Overview\nCRUD operations for tags and categories with case-insensitive uniqueness.\n\n## Why This Matters\nTags and categories are organizational primitives:\n- Users expect \"Swift\" and \"swift\" to be the same tag\n- Orphan cleanup prevents clutter\n- Shared across all views\n\n## TagStore Protocol\n```swift\nprotocol TagStoring: Sendable {\n    func fetchAll() async throws -> [Tag]\n    func fetch(id: UUID) async throws -> Tag?\n    func findByName(_ name: String) async throws -> Tag?  // Case-insensitive\n    func create(name: String) async throws -> Tag\n    func update(_ tag: Tag) async throws\n    func delete(id: UUID) async throws\n    func findOrCreate(name: String) async throws -> Tag\n    func cleanupOrphans() async throws -> Int  // Returns count deleted\n}\n```\n\n## CategoryStore Protocol\n```swift\nprotocol CategoryStoring: Sendable {\n    func fetchAll() async throws -> [Category]\n    func fetch(id: UUID) async throws -> Category?\n    func findByName(_ name: String) async throws -> Category?\n    func create(name: String) async throws -> Category\n    func update(_ category: Category) async throws\n    func delete(id: UUID) async throws\n    func findOrCreate(name: String) async throws -> Category\n}\n```\n\n## Case-Insensitive Uniqueness\nThe schema uses COLLATE NOCASE index:\n```sql\nCREATE UNIQUE INDEX tags_name_nocase ON tags(name COLLATE NOCASE);\n```\n\nIn code:\n```swift\nfunc findByName(_ name: String) async throws -> Tag? {\n    try await dbQueue.read { db in\n        try Tag.filter(Column(\"name\").collating(.nocase) == name).fetchOne(db)\n    }\n}\n\nfunc create(name: String) async throws -> Tag {\n    // Check for existing (case-insensitive)\n    if let existing = try await findByName(name) {\n        throw TagError.alreadyExists(existing: existing)\n    }\n    \n    let tag = Tag(id: UUID(), name: name)\n    try await dbQueue.write { db in\n        try tag.insert(db)\n    }\n    return tag\n}\n```\n\n## findOrCreate Pattern\nCommon operation: get existing or create new:\n```swift\nfunc findOrCreate(name: String) async throws -> Tag {\n    if let existing = try await findByName(name) {\n        return existing\n    }\n    return try await create(name: name)\n}\n```\n\n## Orphan Cleanup\nTags with 0 prompts can be cleaned up:\n```swift\nfunc cleanupOrphans() async throws -> Int {\n    try await dbQueue.write { db in\n        let orphanIds = try Tag\n            .filter(!Tag.hasMany(PromptTag.self).isEmpty == false)\n            .fetchAll(db)\n            .map(\\.id)\n        \n        // Or use SQL directly:\n        let sql = \"\"\"\n            DELETE FROM tags\n            WHERE id NOT IN (SELECT DISTINCT tag_id FROM prompt_tags)\n        \"\"\"\n        try db.execute(sql: sql)\n        return db.changesCount\n    }\n}\n```\n\n## Error Types\n```swift\nenum TagError: Error {\n    case alreadyExists(existing: Tag)\n    case notFound(id: UUID)\n    case inUse(promptCount: Int)  // If we want to warn before delete\n}\n\nenum CategoryError: Error {\n    case alreadyExists(existing: Category)\n    case notFound(id: UUID)\n}\n```\n\n## Acceptance Criteria\n- [ ] CRUD operations work\n- [ ] Case-insensitive lookup works (\"Swift\" finds \"swift\")\n- [ ] Duplicate names rejected\n- [ ] findOrCreate returns existing or creates new\n- [ ] Orphan cleanup removes unused tags\n- [ ] Unit tests for all operations\n- [ ] Edge case: empty name rejected\n\n## References\n- docs/plans/plan.md §4.1 Schema (tags, categories tables)","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:22:45.483783Z","created_by":"mjefferson","updated_at":"2026-01-22T03:22:45.484167Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-2vs","depends_on_id":"pho-3sz","type":"parent-child","created_at":"2026-01-22T03:22:45.484155Z","created_by":"mjefferson"}]}
{"id":"pho-2wr","title":"Implement DatabaseManager","description":"# Implement DatabaseManager\n\n## Overview\nManages SQLite database lifecycle: opening, migrations, closing, and full rebuild from vault files.\n\n## Why This Matters\nDatabaseManager is the gatekeeper for all database access. It ensures:\n- Database is properly initialized before use\n- Migrations run in order\n- Rebuild can restore from corrupted state\n- Clean shutdown on app termination\n\n## Protocol Definition (From plan.md §5.2.1)\n```swift\nprotocol DatabaseManaging: Sendable {\n    var isConnected: Bool { get }\n    func initialize() async throws\n    func rebuild(progress: @escaping (RebuildProgress) -> Void) async throws\n    func close() async\n}\n\nstruct RebuildProgress: Sendable {\n    let phase: RebuildPhase\n    let filesProcessed: Int\n    let totalFiles: Int\n}\n\nenum RebuildPhase: Sendable {\n    case deletingOldDatabase\n    case creatingSchema\n    case scanningVault\n    case indexingFiles\n    case rebuildingFTS\n    case complete\n}\n```\n\n## Implementation as Actor\n```swift\nactor DatabaseManager: DatabaseManaging {\n    private var dbQueue: DatabaseQueue?\n    private let dbPath: URL\n    private let vaultManager: VaultManaging\n    \n    var isConnected: Bool {\n        dbQueue != nil\n    }\n    \n    func initialize() async throws {\n        // 1. Open or create database\n        // 2. Run migrations\n        // 3. Enable WAL mode\n    }\n    \n    func rebuild(progress: ...) async throws {\n        // 1. Close existing connection\n        // 2. Delete database files\n        // 3. Create fresh database\n        // 4. Scan vault for all .md files\n        // 5. Parse and insert each prompt\n        // 6. Rebuild FTS index\n    }\n    \n    func close() async {\n        dbQueue = nil\n    }\n}\n```\n\n## Key Implementation Details\n\n### WAL Mode\nEnable Write-Ahead Logging for better concurrency:\n```swift\ntry dbQueue.write { db in\n    try db.execute(sql: \"PRAGMA journal_mode=WAL\")\n}\n```\n\n### Database Location\n```\n~/Library/Application Support/PromptHoarder/\n├── index.sqlite\n├── index.sqlite-wal\n└── index.sqlite-shm\n```\n\nNote: DB stays in Application Support even if vault is elsewhere.\n\n### Rebuild Safety\n- Rebuild acquires exclusive lock (actor isolation handles this)\n- If rebuild fails mid-process, delete partial DB and show error\n- Vault files are NEVER modified during rebuild\n- Progress callback enables UI feedback\n\n### Error Handling\n```swift\nenum DatabaseError: Error {\n    case notInitialized\n    case migrationFailed(underlying: Error)\n    case rebuildFailed(phase: RebuildPhase, underlying: Error)\n    case corruptDatabase\n}\n```\n\n## Acceptance Criteria\n- [ ] Can initialize new database from scratch\n- [ ] Migrations run automatically on open\n- [ ] WAL mode enabled\n- [ ] Rebuild works end-to-end\n- [ ] Progress reported during rebuild\n- [ ] Handles missing vault gracefully\n- [ ] Unit tests for all scenarios\n\n## References\n- docs/plans/plan.md §5.2.1 DatabaseManager\n- docs/plans/plan.md §2.4 Index rebuild process","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:18:14.856122Z","created_by":"mjefferson","updated_at":"2026-01-22T03:21:45.217396Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-2wr","depends_on_id":"pho-3n0","type":"parent-child","created_at":"2026-01-22T03:18:14.856533Z","created_by":"mjefferson"},{"issue_id":"pho-2wr","depends_on_id":"pho-kk1","type":"blocks","created_at":"2026-01-22T03:21:45.217384Z","created_by":"mjefferson"}]}
{"id":"pho-30e","title":"Phase 1.5: Menu Bar","description":"# Phase 1.5: Menu Bar\n\n## Overview\nThe menu bar popover is THE primary access point for Prompt Hoarder. Users invoke it from any app, search, and copy a prompt—all without switching contexts.\n\n## Why This Matters (Strategic Context)\nThis is the CORE VALUE PROPOSITION. Everything else supports this.\n\n**If the menu bar is slow or clunky, users will just keep prompts in Notes.app.**\n\nThe menu bar must be:\n- **Instant** — Appears in <100ms, search results in <200ms\n- **Minimal** — No distractions, just search + results\n- **Complete** — Variable resolution happens inline, no app switch needed\n\n## Key Components\n\n### MenuBarManager\n- NSStatusItem setup (menu bar icon)\n- Popover lifecycle (show/hide)\n- Global activation handling\n- Keyboard event passthrough\n\n### MenuBarPopover\n- Search field (auto-focused on open)\n- Results list with keyboard navigation\n- Tabs: Favorites / Recent / Workflows\n- Footer: Settings, Open Library\n\n### QuickSearchView\n- Real-time search (debounced ~100ms)\n- Result highlighting\n- Empty state handling\n- Loading state for slow searches\n\n### VariableResolverSheet\n- Inline form for variable values\n- Auto-populate defaults from template\n- Tab between fields\n- Copy button submits form\n\n## UX Requirements (Critical Path)\n| Action | UX |\n|--------|-----|\n| Open popover | Click status item OR global hotkey (Phase 2) |\n| Start searching | Just type (search field auto-focused) |\n| Navigate results | Up/Down arrow keys |\n| Select prompt | Enter key |\n| Fill variables | Sheet appears, Tab between fields |\n| Copy result | Enter or click Copy |\n| Close | Escape key |\n\n**Flow must be: activate → type → down → enter → [fill vars] → enter → done**\n\nMaximum 3-4 interactions from activation to clipboard.\n\n## Technical Challenges\n\n### Popover Focus (Notoriously Finicky)\n- Must work when app is NOT frontmost\n- Search field must auto-focus on open\n- Keyboard events must route correctly\n- Test across macOS versions (14, 15+)\n\n### Performance\n- Search latency target: <200ms from keystroke to results\n- Popover appear time: <100ms\n- No animation stutter during search\n\n### State Management\n- Popover state survives show/hide cycles\n- Recent items tracked across sessions\n- Search query cleared on close (or preserved?)\n\n## Architecture Notes\n\n### SwiftUI MenuBarExtra\nmacOS 14+ has native `MenuBarExtra` in SwiftUI:\n```swift\nMenuBarExtra(\"Prompt Hoarder\", systemImage: \"doc.text\") {\n    MenuBarPopoverView()\n}\n.menuBarExtraStyle(.window)\n```\n\nBenefits:\n- Native SwiftUI (no AppKit bridge)\n- Built-in popover behavior\n- System-consistent appearance\n\n### Data Flow\n```\nMenuBarPopover\n    └── MenuBarViewModel (@Observable @MainActor)\n            └── SearchViewModel\n            └── PromptStore (actor)\n                    └── SQLite FTS5\n```\n\n## Testing Requirements\n- UI tests for search + copy flow\n- Performance benchmark: keystroke to results <200ms\n- Focus testing across macOS versions\n- Test with app in background\n\n## This Epic Can Parallel With\n- Phase 1.4 Main Window UI\n\n## This Epic Requires\n- Phase 1.2 Core Data Layer\n- Phase 1.3 Domain Services (especially VariableResolver)\n\n## References\n- docs/plans/plan.md §6.2 Menu Bar Popover wireframe\n- docs/plans/plan.md §6.3 Variable Resolver Sheet wireframe","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-22T03:14:20.732614Z","created_by":"mjefferson","updated_at":"2026-01-22T03:15:38.310450Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-30e","depends_on_id":"pho-1qw","type":"parent-child","created_at":"2026-01-22T03:14:20.733005Z","created_by":"mjefferson"},{"issue_id":"pho-30e","depends_on_id":"pho-3sz","type":"blocks","created_at":"2026-01-22T03:15:38.310436Z","created_by":"mjefferson"}]}
{"id":"pho-30g","title":"Build SidebarView with sections","description":"# Build SidebarView\n\n## Overview\nNavigation sidebar with All Prompts, Favorites, Categories, Tags, and Workflows sections.\n\n## Structure\n```swift\nstruct SidebarView: View {\n    @Binding var selection: SidebarSection?\n    @Environment(LibraryViewModel.self) private var viewModel\n    \n    var body: some View {\n        List(selection: $selection) {\n            Section(\"Library\") {\n                Label(\"All Prompts\", systemImage: \"doc.text\")\n                    .tag(SidebarSection.allPrompts)\n                Label(\"Favorites\", systemImage: \"star\")\n                    .tag(SidebarSection.favorites)\n                Label(\"Recent\", systemImage: \"clock\")\n                    .tag(SidebarSection.recent)\n            }\n            \n            Section(\"Categories\") {\n                ForEach(viewModel.categories) { category in\n                    Label(category.name, systemImage: \"folder\")\n                        .tag(SidebarSection.category(category))\n                }\n            }\n            \n            Section(\"Tags\") {\n                ForEach(viewModel.tags) { tag in\n                    Label(tag.name, systemImage: \"tag\")\n                        .tag(SidebarSection.tag(tag))\n                }\n            }\n            \n            Section(\"Workflows\") {\n                Label(\"All Workflows\", systemImage: \"arrow.triangle.branch\")\n                    .tag(SidebarSection.workflows)\n            }\n        }\n        .listStyle(.sidebar)\n    }\n}\n```\n\n## Features\n- Collapsible sections\n- Badge counts (optional: show count of prompts per section)\n- Context menus for categories/tags (rename, delete)\n\n## Acceptance Criteria\n- [ ] All sections render\n- [ ] Selection state binds correctly\n- [ ] Categories populate from ViewModel\n- [ ] Tags populate from ViewModel\n- [ ] Sections collapsible","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:26:11.494237Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:26.647948Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-30g","depends_on_id":"pho-24o","type":"parent-child","created_at":"2026-01-22T03:26:11.494632Z","created_by":"mjefferson"},{"issue_id":"pho-30g","depends_on_id":"pho-2vd","type":"blocks","created_at":"2026-01-22T03:27:26.647933Z","created_by":"mjefferson"}]}
{"id":"pho-35g","title":"Implement VaultAccessCoordinator","description":"# Implement VaultAccessCoordinator\n\n## Overview\nManages security-scoped bookmark lifecycle and vault access permissions. Essential for macOS sandboxing compatibility.\n\n## Why This Matters\nmacOS sandboxing restricts file access. Security-scoped bookmarks allow persistent access to user-selected folders:\n- Works with both sandboxed and non-sandboxed builds\n- Survives app restart\n- Handles moved/renamed folders gracefully\n\n## Protocol Definition (From plan.md §5.1)\n```swift\nprotocol VaultAccessCoordinating: Sendable {\n    var vaultURL: URL? { get }\n    func resolveBookmark() async -> Bool\n    func storeBookmark(for url: URL) throws\n    func startAccessing() -> Bool\n    func stopAccessing()\n}\n\nenum VaultAccessError: Error {\n    case bookmarkNotFound\n    case bookmarkStale(lastKnownPath: String)\n    case accessDenied\n}\n```\n\n## Implementation as Actor\n```swift\nactor VaultAccessCoordinator: VaultAccessCoordinating {\n    private var currentURL: URL?\n    private var isAccessing = false\n    private let userDefaults = UserDefaults.standard\n    \n    private let bookmarkKey = \"vaultBookmarkData\"\n    private let pathKey = \"vaultLastKnownPath\"\n    \n    var vaultURL: URL? {\n        currentURL\n    }\n    \n    func resolveBookmark() async -> Bool {\n        guard let bookmarkData = userDefaults.data(forKey: bookmarkKey) else {\n            return false\n        }\n        \n        var isStale = false\n        do {\n            let url = try URL(\n                resolvingBookmarkData: bookmarkData,\n                options: .withSecurityScope,\n                relativeTo: nil,\n                bookmarkDataIsStale: &isStale\n            )\n            \n            if isStale {\n                // Regenerate bookmark\n                try storeBookmark(for: url)\n            }\n            \n            currentURL = url\n            return true\n        } catch {\n            return false\n        }\n    }\n    \n    func storeBookmark(for url: URL) throws {\n        let bookmarkData = try url.bookmarkData(\n            options: .withSecurityScope,\n            includingResourceValuesForKeys: nil,\n            relativeTo: nil\n        )\n        userDefaults.set(bookmarkData, forKey: bookmarkKey)\n        userDefaults.set(url.path, forKey: pathKey)\n    }\n    \n    func startAccessing() -> Bool {\n        guard let url = currentURL, !isAccessing else { return false }\n        isAccessing = url.startAccessingSecurityScopedResource()\n        return isAccessing\n    }\n    \n    func stopAccessing() {\n        guard isAccessing, let url = currentURL else { return }\n        url.stopAccessingSecurityScopedResource()\n        isAccessing = false\n    }\n}\n```\n\n## Lifecycle Management\n\n### App Launch\n```swift\n// In PromptHoarderApp.init or AppDelegate\nlet coordinator = VaultAccessCoordinator()\n\n// Attempt to resolve stored bookmark\nif await coordinator.resolveBookmark() {\n    let _ = coordinator.startAccessing()\n} else {\n    // Show vault selection UI\n}\n```\n\n### App Termination\n```swift\n// Balance the startAccessing call\ncoordinator.stopAccessing()\n```\n\n### Bookmark Failure Handling\nWhen bookmark resolution fails (user moved/renamed folder):\n1. Show alert: \"Vault folder not found at expected location\"\n2. Offer actions:\n   - **Locate Vault**: File picker to re-resolve\n   - **Use Default**: Reset to `~/Library/Application Support/PromptHoarder/Vault/`\n3. After re-selection, store new bookmark\n\n## Default Vault Location\n```swift\nstatic var defaultVaultURL: URL {\n    FileManager.default\n        .urls(for: .applicationSupportDirectory, in: .userDomainMask)\n        .first!\n        .appendingPathComponent(\"PromptHoarder\")\n        .appendingPathComponent(\"Vault\")\n}\n```\n\n## Logging\nLog all state transitions for debugging permission issues:\n```swift\nlogger.info(\"Vault access started: \\(url.path)\")\nlogger.warning(\"Bookmark stale, regenerating\")\nlogger.error(\"Failed to resolve bookmark: \\(error)\")\n```\n\n## Acceptance Criteria\n- [ ] Can store bookmark from NSOpenPanel URL\n- [ ] Can resolve stored bookmark on launch\n- [ ] Handles stale bookmarks (regenerates)\n- [ ] Handles missing bookmarks (prompts user)\n- [ ] startAccessing/stopAccessing properly balanced\n- [ ] Works with sandboxed build\n- [ ] Unit tests for all scenarios\n\n## References\n- docs/plans/plan.md §5.1 VaultAccessCoordinator\n- docs/plans/plan.md §2.4 Vault location + macOS sandboxing\n- Apple: Security-Scoped Bookmarks","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:19:10.851813Z","created_by":"mjefferson","updated_at":"2026-01-22T03:19:10.852238Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-35g","depends_on_id":"pho-3n0","type":"parent-child","created_at":"2026-01-22T03:19:10.852227Z","created_by":"mjefferson"}]}
{"id":"pho-393","title":"Add project dependencies","description":"# Add Project Dependencies\n\n## Overview\nAdd all required third-party dependencies to Package.swift and verify they resolve correctly.\n\n## Dependencies to Add\n\n### PromptHoarderCore Dependencies\n| Package | Version | Purpose |\n|---------|---------|---------|\n| GRDB.swift | 7.0+ | SQLite with FTS5, migrations |\n| swift-log | 1.6+ | Structured logging |\n| swift-markdown | 0.5+ | Markdown parsing for preview |\n\n### PromptHoarder (App) Dependencies\n| Package | Version | Purpose |\n|---------|---------|---------|\n| Sparkle | 2.8+ | Auto-updates for direct distribution |\n\n## Why These Choices (Rationale)\n\n### GRDB over alternatives\n- **Core Data**: Overkill for our model, poor FTS support\n- **SQLite.swift**: No FTS5 support at all\n- **Raw SQLite**: Too low-level, no migrations\n- **GRDB**: Best docs, FTS5 native, migrations, @Observable support\n\n### swift-markdown over alternatives\n- **cmark**: C dependency, harder to integrate\n- **Down**: Wraps cmark, same problem\n- **Custom**: Why reinvent when Apple provides?\n\n### swift-log over alternatives\n- **print()**: No log levels, no structured data\n- **OSLog**: Less portable to CLI\n- **swift-log**: Ecosystem standard, pluggable backends\n\n### Sparkle\n- De facto standard for macOS app updates\n- 10+ years of battle-testing\n- Alternative: App Store (but sandboxing limits paste injection later)\n\n## Package.swift Additions\n```swift\ndependencies: [\n    .package(url: \"https://github.com/groue/GRDB.swift\", from: \"7.0.0\"),\n    .package(url: \"https://github.com/apple/swift-log\", from: \"1.6.0\"),\n    .package(url: \"https://github.com/apple/swift-markdown\", from: \"0.5.0\"),\n    .package(url: \"https://github.com/sparkle-project/Sparkle\", from: \"2.8.0\"),\n]\n```\n\n## Dependency Health Check\nBefore adding, verify:\n- [ ] Recent release (within last 6 months)\n- [ ] Active maintenance (commits, issue responses)\n- [ ] Compatible with Swift 6 / macOS 14\n- [ ] No concerning security issues\n\n## Acceptance Criteria\n- [ ] `swift package resolve` succeeds\n- [ ] All dependencies appear in Package.resolved\n- [ ] `swift build` still succeeds\n- [ ] Can `import GRDB` in Core target\n- [ ] Can `import Logging` in Core target\n- [ ] Can `import Markdown` in Core target\n- [ ] Can `import Sparkle` in App target\n\n## Note\nKeyboardShortcuts (for global hotkeys) deferred to Phase 2.\n\n## References\n- docs/plans/plan.md §3.1 Dependencies\n- docs/plans/plan.md §3.2 Dependency Rationale","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:16:29.668318Z","created_by":"mjefferson","updated_at":"2026-01-22T03:17:32.683038Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-393","depends_on_id":"pho-1zt","type":"parent-child","created_at":"2026-01-22T03:16:29.668695Z","created_by":"mjefferson"},{"issue_id":"pho-393","depends_on_id":"pho-3uh","type":"blocks","created_at":"2026-01-22T03:17:32.683025Z","created_by":"mjefferson"}]}
{"id":"pho-3bg","title":"Implement ImportService","description":"# Implement ImportService\n\n## Overview\nImport prompts from single files or folders with ID conflict resolution.\n\n## Why This Matters\nUsers may:\n- Have existing prompts in Markdown files\n- Restore from a backup\n- Receive prompts from others\n\nImport must handle all edge cases gracefully.\n\n## Service Definition\n```swift\nprotocol ImportServiceProtocol: Sendable {\n    func importFile(_ url: URL) async throws -> ImportResult\n    func importFolder(_ url: URL, onConflict: @escaping (ImportConflict) async -> ConflictResolution) async throws -> [ImportResult]\n}\n\nstruct ImportResult: Sendable {\n    let url: URL\n    let promptId: UUID?        // nil if import failed\n    let error: ImportError?\n    let previousId: UUID?      // non-nil if ID conflict resulted in new UUID\n    let status: ImportStatus\n}\n\nenum ImportStatus {\n    case imported\n    case replaced\n    case skipped\n    case failed\n}\n\nstruct ImportConflict: Sendable {\n    let url: URL\n    let existingPrompt: PromptSummary\n    let newTitle: String\n}\n\nenum ConflictResolution {\n    case importAsCopy   // Generate new UUID\n    case replaceExisting\n    case skip\n}\n\nenum ImportError: Error {\n    case invalidFormat\n    case notUTF8\n    case fileTooLarge(size: Int64)\n    case parseError(String)\n    case idConflict(existingId: UUID)\n}\n```\n\n## Import Flow\n\n### Single File\n```swift\nfunc importFile(_ url: URL) async throws -> ImportResult {\n    // 1. Validate file\n    guard url.pathExtension == \"md\" else {\n        return ImportResult(url: url, error: .invalidFormat, status: .failed)\n    }\n    \n    let size = try FileManager.default.attributesOfItem(atPath: url.path)[.size] as! Int64\n    guard size < 1_000_000 else {  // 1MB limit\n        return ImportResult(url: url, error: .fileTooLarge(size: size), status: .failed)\n    }\n    \n    // 2. Read and parse\n    guard let content = try? String(contentsOf: url, encoding: .utf8) else {\n        return ImportResult(url: url, error: .notUTF8, status: .failed)\n    }\n    \n    let prompt = try parsePromptFile(content: content, sourceURL: url)\n    \n    // 3. Check for ID conflict\n    if let existing = try await promptStore.fetch(id: prompt.id) {\n        throw ImportError.idConflict(existingId: existing.id)\n    }\n    \n    // 4. Save\n    try await promptStore.save(prompt)\n    \n    return ImportResult(url: url, promptId: prompt.id, status: .imported)\n}\n```\n\n### Bulk Folder Import\n```swift\nfunc importFolder(\n    _ url: URL,\n    onConflict: @escaping (ImportConflict) async -> ConflictResolution\n) async throws -> [ImportResult] {\n    var results: [ImportResult] = []\n    \n    let files = try FileManager.default.contentsOfDirectory(\n        at: url,\n        includingPropertiesForKeys: nil\n    ).filter { $0.pathExtension == \"md\" }\n    \n    for file in files {\n        do {\n            let result = try await importFile(file)\n            results.append(result)\n        } catch ImportError.idConflict(let existingId) {\n            // Ask user for resolution\n            let existing = try await promptStore.fetchSummary(id: existingId)!\n            let prompt = try parsePromptFile(at: file)\n            \n            let conflict = ImportConflict(\n                url: file,\n                existingPrompt: existing,\n                newTitle: prompt.title\n            )\n            \n            let resolution = await onConflict(conflict)\n            let result = try await handleConflict(file: file, prompt: prompt, resolution: resolution)\n            results.append(result)\n        } catch {\n            results.append(ImportResult(url: file, error: error as? ImportError, status: .failed))\n        }\n    }\n    \n    return results\n}\n```\n\n### Conflict Resolution\n```swift\nfunc handleConflict(\n    file: URL,\n    prompt: Prompt,\n    resolution: ConflictResolution\n) async throws -> ImportResult {\n    switch resolution {\n    case .importAsCopy:\n        var newPrompt = prompt\n        let originalId = prompt.id\n        newPrompt.id = UUID()\n        newPrompt.title = \"\\(prompt.title) (Imported)\"\n        try await promptStore.save(newPrompt)\n        return ImportResult(url: file, promptId: newPrompt.id, previousId: originalId, status: .imported)\n        \n    case .replaceExisting:\n        try await promptStore.save(prompt)  // Overwrites existing\n        return ImportResult(url: file, promptId: prompt.id, status: .replaced)\n        \n    case .skip:\n        return ImportResult(url: file, status: .skipped)\n    }\n}\n```\n\n## File Parsing\n```swift\nfunc parsePromptFile(content: String, sourceURL: URL) throws -> Prompt {\n    // Split front matter and body\n    guard let (frontMatter, body) = splitFrontMatter(content) else {\n        throw ImportError.parseError(\"No front matter found\")\n    }\n    \n    // Parse YAML\n    let yaml = try YAMLDecoder().decode(PromptFrontMatter.self, from: frontMatter)\n    \n    // Build prompt\n    let id = yaml.id ?? UUID()  // Generate if missing\n    return Prompt(\n        id: id,\n        title: yaml.title ?? sourceURL.deletingPathExtension().lastPathComponent,\n        content: body,\n        tags: yaml.tags?.map { Tag(id: UUID(), name: $0) } ?? [],\n        category: yaml.category.map { Category(id: UUID(), name: $0) },\n        isFavorite: yaml.favorite ?? false,\n        isArchived: false,\n        createdAt: yaml.created_at ?? Date(),\n        updatedAt: yaml.updated_at ?? Date(),\n        usageCount: 0,\n        lastUsedAt: nil\n    )\n}\n```\n\n## Edge Cases (From plan.md §2.4)\n| Scenario | Handling |\n|----------|----------|\n| No ID in front matter | Generate new UUID |\n| Malformed ID | Treat as no ID, log warning |\n| Non-UTF8 file | Skip with error |\n| File >1MB | Skip with error |\n| Symlinks | Follow (or skip, configurable) |\n| Cloud placeholders | Skip |\n| Conflicted copies | Skip |\n| No front matter | Best-effort: use filename as title |\n\n## Acceptance Criteria\n- [ ] Single file import works\n- [ ] Bulk folder import works\n- [ ] ID conflict detection works\n- [ ] Conflict resolution: Import as Copy\n- [ ] Conflict resolution: Replace Existing\n- [ ] Conflict resolution: Skip\n- [ ] Non-UTF8 files skipped with warning\n- [ ] Large files skipped with warning\n- [ ] Missing ID generates new UUID\n- [ ] Unit tests for all scenarios\n\n## References\n- docs/plans/plan.md §2.4 Import ID conflict resolution","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:24:31.215335Z","created_by":"mjefferson","updated_at":"2026-01-22T03:24:41.295710Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-3bg","depends_on_id":"pho-2vs","type":"blocks","created_at":"2026-01-22T03:24:41.295695Z","created_by":"mjefferson"},{"issue_id":"pho-3bg","depends_on_id":"pho-3sz","type":"parent-child","created_at":"2026-01-22T03:24:31.215742Z","created_by":"mjefferson"}]}
{"id":"pho-3g6","title":"Build WorkflowBuilderView","description":"# Build WorkflowBuilderView\n\n## Overview\nUI for creating and editing workflows: add prompts, reorder steps, configure variables.\n\n## Key Features\n- Add prompts from library (search/browse)\n- Drag-drop reordering of steps\n- Step notes (per-step context)\n- Variable override configuration\n- Remove step action\n\n## Implementation Approach\n- List of WorkflowStep items\n- onMove modifier for drag-drop\n- Sheet for adding prompts\n- Inline editing for step notes\n- Save/Cancel buttons in toolbar\n\n## Acceptance Criteria\n- [ ] Can add prompts to workflow\n- [ ] Drag-drop reordering works\n- [ ] Can edit step notes\n- [ ] Can configure variable overrides\n- [ ] Can remove steps\n- [ ] Save persists workflow","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:27:14.953184Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:14.953546Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-3g6","depends_on_id":"pho-1nn","type":"parent-child","created_at":"2026-01-22T03:27:14.953535Z","created_by":"mjefferson"}]}
{"id":"pho-3gy","title":"Set up SwiftLint and SwiftFormat","description":"# Set up SwiftLint and SwiftFormat\n\n## Overview\nConfigure code quality tools to maintain consistent style across the codebase.\n\n## Why This Matters\n- **Consistent style** reduces cognitive load when reading code\n- **Automated formatting** eliminates style debates in code review\n- **Lint rules** catch common mistakes before they become bugs\n- **CI enforcement** prevents regressions\n\n## Tools\n\n### SwiftLint\nStatic analysis for Swift code quality.\n\nInstallation: `brew install swiftlint`\n\n### SwiftFormat\nAutomatic code formatting.\n\nInstallation: `brew install swiftformat`\n\n## Configuration Files\n\n### .swiftlint.yml\n```yaml\n# Paths to include/exclude\nincluded:\n  - Sources\n  - Tests\n\nexcluded:\n  - .build\n\n# Rules configuration\nline_length:\n  warning: 120\n  error: 150\n  ignores_comments: true\n\n# Disable overly pedantic rules\ndisabled_rules:\n  - trailing_comma  # We allow trailing commas\n\n# Enable additional rules\nopt_in_rules:\n  - force_unwrapping  # Warn on force unwrap\n  - empty_count       # Prefer isEmpty over count == 0\n\n# Type name requirements\ntype_name:\n  min_length: 2\n  max_length: 50\n\n# Identifier name requirements  \nidentifier_name:\n  min_length: 1\n  max_length: 50\n```\n\n### .swiftformat\n```\n# Indentation\n--indent 4\n--indentcase false\n\n# Wrapping\n--wraparguments before-first\n--wrapcollections before-first\n--maxwidth 120\n\n# Spacing\n--trimwhitespace always\n--insertlines blank\n\n# Misc\n--self remove\n--stripunusedargs closure-only\n```\n\n## Scripts\n\n### scripts/lint.sh\n```bash\n#!/bin/bash\nswiftlint lint --strict\n```\n\n### scripts/format.sh\n```bash\n#!/bin/bash\nswiftformat Sources Tests --lint\n```\n\n### scripts/format-fix.sh\n```bash\n#!/bin/bash\nswiftformat Sources Tests\n```\n\n## CI Integration (Optional)\nConsider adding to CI pipeline:\n```yaml\n- name: Lint\n  run: ./scripts/lint.sh\n- name: Format check\n  run: ./scripts/format.sh\n```\n\n## Acceptance Criteria\n- [ ] swiftlint passes on all existing code\n- [ ] swiftformat produces no changes (code already formatted)\n- [ ] .swiftlint.yml committed to repo\n- [ ] .swiftformat committed to repo\n- [ ] scripts/lint.sh works from repo root\n- [ ] scripts/format.sh works from repo root\n\n## Note\nConsider pre-commit hook (optional):\n```bash\n#!/bin/bash\nswiftformat Sources Tests\nswiftlint lint --strict\n```","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:17:21.680151Z","created_by":"mjefferson","updated_at":"2026-01-22T03:17:32.723172Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-3gy","depends_on_id":"pho-1zt","type":"parent-child","created_at":"2026-01-22T03:17:21.680539Z","created_by":"mjefferson"},{"issue_id":"pho-3gy","depends_on_id":"pho-3uh","type":"blocks","created_at":"2026-01-22T03:17:32.723160Z","created_by":"mjefferson"}]}
{"id":"pho-3km","title":"Implement VaultManager","description":"# Implement VaultManager\n\n## Overview\nHandles file system operations: reading, writing, scanning vault, and handling external changes. This is where atomic writes and cloud sync artifact filtering happen.\n\n## Why This Matters\nVaultManager is the bridge between the file system and the database. It must:\n- Never lose data (atomic writes)\n- Detect all changes (scan + watch)\n- Filter noise (cloud sync artifacts)\n- Handle edge cases (cross-volume, case-rename)\n\n## Protocol Definition (From plan.md §5.2)\n```swift\nprotocol VaultManaging: Sendable {\n    var vaultURL: URL { get }\n    \n    func scanVault() async throws -> VaultScanResult\n    func readPromptContent(id: UUID) async throws -> String\n    func writePromptContent(id: UUID, content: String) async throws\n    func deletePromptFile(id: UUID) async throws\n    func importFiles(_ urls: [URL]) async throws -> [ImportResult]\n    func exportPrompt(_ prompt: Prompt, to url: URL) async throws\n    func exportLibrary(to url: URL) async throws\n}\n\nstruct VaultScanResult {\n    let newFiles: [URL]\n    let modifiedFiles: [URL]\n    let deletedIds: [UUID]\n}\n\nenum WriteError: Error {\n    case insufficientSpace(required: Int64, available: Int64)\n    case permissionDenied(path: URL)\n    case fileLocked(path: URL, afterRetries: Int)\n    case directoryNotFound(path: URL)\n}\n```\n\n## Atomic Write Implementation (Critical)\n\n### Standard Write\n```swift\nfunc writePromptContent(id: UUID, content: String) async throws {\n    let targetURL = vaultURL.appendingPathComponent(\"\\(id.uuidString).md\")\n    \n    // Pre-flight checks\n    try checkAvailableSpace(for: content)\n    try checkWritePermission(for: vaultURL)\n    \n    // Create temp file IN SAME DIRECTORY (critical for atomicity)\n    let tempURL = vaultURL.appendingPathComponent(\".\\(UUID().uuidString).tmp\")\n    \n    try content.write(to: tempURL, atomically: true, encoding: .utf8)\n    \n    // Atomic replace\n    try FileManager.default.replaceItemAt(targetURL, withItemAt: tempURL)\n}\n```\n\n### Edge Cases (From plan.md §2.4)\n\n**Cross-volume vault:**\nTemp file MUST be in vault directory, not `/tmp`. Otherwise `replaceItemAt` falls back to non-atomic copy+delete.\n\n**Case-only rename (`Foo.md` → `foo.md`):**\nAPFS case-insensitivity requires intermediate:\n```swift\nfunc caseOnlyRename(from: URL, to: URL) throws {\n    let intermediate = from.deletingLastPathComponent()\n        .appendingPathComponent(\".\\(UUID().uuidString).tmp\")\n    try FileManager.default.moveItem(at: from, to: intermediate)\n    try FileManager.default.moveItem(at: intermediate, to: to)\n}\n```\n\n**Disk full:**\nCheck available space before write:\n```swift\nfunc checkAvailableSpace(for content: String) throws {\n    let required = Int64(content.utf8.count * 2)  // 2x safety margin\n    let available = try availableSpace(at: vaultURL)\n    if available < required {\n        throw WriteError.insufficientSpace(required: required, available: available)\n    }\n}\n```\n\n**File locked:**\nRetry with backoff:\n```swift\nfunc writeWithRetry(...) async throws {\n    let delays = [100, 500, 1000]  // milliseconds\n    for (attempt, delay) in delays.enumerated() {\n        do {\n            try write(...)\n            return\n        } catch {\n            if attempt < delays.count - 1 && isLockError(error) {\n                try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000))\n                continue\n            }\n            throw WriteError.fileLocked(path: url, afterRetries: delays.count)\n        }\n    }\n}\n```\n\n## Vault Scan Implementation\n\n### Ignore Patterns (From plan.md §5.2)\n```swift\nstatic let ignorePatterns: [NSRegularExpression] = [\n    #\"^\\..+\\.icloud$\"#,           // iCloud placeholders\n    #\".+ \\(.*conflicted copy.*\\).+\"#,  // Dropbox/OneDrive conflicts\n    #\".+\\.swp$\"#,                 // Vim swap\n    #\".+~$\"#,                     // Backup files\n    #\"^\\.#.+\"#,                   // Emacs locks\n    #\"^#.+#$\"#,                   // Emacs auto-save\n    #\"^\\.DS_Store$\"#,             // macOS metadata\n    #\"^\\._.*\"#,                   // macOS resource forks\n    #\".+\\.tmp$\"#,                 // Generic temp\n].compactMap { try? NSRegularExpression(pattern: $0) }\n```\n\n### Incremental Scan\nTrack mtime + file size, only re-parse changed files:\n```swift\nstruct FileState: Codable {\n    let mtime: Date\n    let size: Int64\n}\n\nfunc scanVault() async throws -> VaultScanResult {\n    let previousState = loadPreviousState()\n    var newFiles: [URL] = []\n    var modifiedFiles: [URL] = []\n    \n    for url in enumerateMarkdownFiles() {\n        if shouldIgnore(url) { continue }\n        \n        let currentState = fileState(for: url)\n        \n        if let previous = previousState[url.path] {\n            if currentState != previous {\n                modifiedFiles.append(url)\n            }\n        } else {\n            newFiles.append(url)\n        }\n    }\n    \n    // Detect deleted\n    let currentPaths = Set(enumerateMarkdownFiles().map(\\.path))\n    let deletedIds = previousState.keys\n        .filter { !currentPaths.contains($0) }\n        .compactMap { extractId(from: $0) }\n    \n    return VaultScanResult(newFiles: newFiles, modifiedFiles: modifiedFiles, deletedIds: deletedIds)\n}\n```\n\n## Acceptance Criteria\n- [ ] Atomic writes work correctly\n- [ ] Cross-volume vaults handled\n- [ ] Case-only renames work on APFS\n- [ ] Disk full detected before write\n- [ ] Retry with backoff for locked files\n- [ ] Vault scan detects new/modified/deleted\n- [ ] Cloud sync artifacts filtered\n- [ ] Log skipped files at debug level\n- [ ] Unit tests for all edge cases\n\n## References\n- docs/plans/plan.md §5.2 VaultManager\n- docs/plans/plan.md §2.4 Atomic write edge cases","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:19:10.877915Z","created_by":"mjefferson","updated_at":"2026-01-22T03:21:45.266269Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-3km","depends_on_id":"pho-35g","type":"blocks","created_at":"2026-01-22T03:21:45.266257Z","created_by":"mjefferson"},{"issue_id":"pho-3km","depends_on_id":"pho-3n0","type":"parent-child","created_at":"2026-01-22T03:19:10.878291Z","created_by":"mjefferson"}]}
{"id":"pho-3n0","title":"Phase 1.2: Core Data Layer","description":"# Phase 1.2: Core Data Layer\n\n## Overview\nImplement the foundational storage layer: SQLite database, vault file management, and the synchronization logic between them. This is the MOST CRITICAL layer—data integrity depends on getting this right.\n\n## Why This Matters (Strategic Context)\nThe hybrid storage model (files + SQLite) is central to Prompt Hoarder's value proposition and design principles:\n\n| Design Principle | How This Layer Implements It |\n|------------------|------------------------------|\n| Files are forever | Prompts stored as Markdown files |\n| Rebuild-ability | SQLite is derived, can be deleted and rebuilt |\n| Speed above all | FTS5 search in SQLite for instant results |\n\n**If this layer has bugs, users lose data. If it's slow, the app feels sluggish.**\n\n## The Hybrid Model Explained\n\n### Why Two Storage Systems?\n| Concern | Files Alone | SQLite Alone | Hybrid (Our Choice) |\n|---------|-------------|--------------|---------------------|\n| Portability | ✅ Plain text | ❌ Proprietary | ✅ Files portable |\n| Search speed | ❌ Scan all files | ✅ FTS5 instant | ✅ FTS5 on cache |\n| Sync compat | ✅ Git/Dropbox | ⚠️ DB conflicts | ✅ Files sync, DB rebuilds |\n| Corruption recovery | ✅ Always readable | ❌ Data loss | ✅ Rebuild from files |\n\n### The Critical Invariant\n**Files are ALWAYS the source of truth. SQLite is a derived, rebuildable index.**\n\nThis means:\n- On conflict, file wins\n- If SQLite corrupts, delete and rebuild\n- All canonical data lives in Markdown front matter\n\n## Key Components\n\n### DatabaseManager\n- SQLite lifecycle (open, migrate, close)\n- Full rebuild from vault files\n- Progress reporting for UI\n- Exclusive lock during rebuild operations\n\n### VaultAccessCoordinator\n- Security-scoped bookmark management (essential for sandboxing)\n- Handle stale/moved vault folder gracefully\n- Balance startAccessing/stopAccessing calls\n\n### VaultManager\n- File I/O with ATOMIC writes (critical for data safety)\n- Vault scanning (detect new, modified, deleted files)\n- Cloud sync artifact filtering (iCloud, Dropbox temp files)\n- Cross-volume handling (temp files in same directory)\n\n### PromptStore\n- CRUD operations via GRDB\n- FTS5 search with filters\n- Archive/delete with workflow reference checking\n- Dual ID system (UUID for app, sqlite_id for FTS)\n\n### FileWatcher\n- Monitor open files for external changes\n- DispatchSource-based file monitoring\n- Conflict detection and UI hooks\n- Debounced events (100ms) to avoid spam\n\n## Critical Edge Cases (From plan.md §2.4)\n\n### Atomic Write Edge Cases\n| Scenario | Handling |\n|----------|----------|\n| Cross-volume vault | Temp file in vault dir (`.uuid.tmp`), not `/tmp` |\n| Case-only rename | Intermediate: `Foo.md` → `.foo.tmp` → `foo.md` |\n| Disk full | Pre-check space (2× file size heuristic) |\n| Permission denied | Fail fast, actionable error, no temp file left |\n| File locked | Retry with backoff (3 attempts: 100ms/500ms/1s) |\n\n### External Edit Handling\nTwo-layer detection:\n1. **FSEvents watcher** — Real-time banner: \"File changed on disk. [Reload] [Ignore]\"\n2. **Save-time hash check** — Safety net if FSEvents missed it\n\nConflict resolution UI:\n- Keep Mine\n- Use Disk Version\n- Duplicate as New Prompt (new UUID)\n\n### Deletion Semantics\nPrompts referenced by workflows CANNOT be hard-deleted silently:\n1. Check `workflow_steps` for references BEFORE attempting delete\n2. If referenced → return error with affected workflow IDs\n3. Default action is Archive (soft delete)\n4. FK constraint `ON DELETE RESTRICT` is safety net\n\n## Testing Requirements\n- 90%+ coverage on PromptStore (CRUD, search, filters)\n- 85%+ coverage on VaultManager (file ops, scans)\n- Integration tests for file↔DB sync\n- Edge case tests for ALL atomic write scenarios\n- Conflict resolution flow tests\n\n## Performance Targets\n- Search: <200ms for 5,000 prompts\n- Vault scan: <2s incremental, <30s full rebuild\n- File read: <50ms single file\n\n## This Epic Blocks\n- Phase 1.3 Domain Services (needs storage layer)\n- Phase 1.4+ UI work (needs PromptStore)\n\n## This Epic Requires\n- Phase 1.1 Project Setup complete\n\n## References\n- docs/plans/plan.md §2.4 Requirements, Constraints, Edge Cases\n- docs/plans/plan.md §4 Data Model\n- docs/plans/plan.md §5.1-5.4 Core Services","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-22T03:13:06.348295Z","created_by":"mjefferson","updated_at":"2026-01-22T03:15:38.265358Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-3n0","depends_on_id":"pho-1qw","type":"parent-child","created_at":"2026-01-22T03:13:06.348677Z","created_by":"mjefferson"},{"issue_id":"pho-3n0","depends_on_id":"pho-1zt","type":"blocks","created_at":"2026-01-22T03:15:38.265345Z","created_by":"mjefferson"}]}
{"id":"pho-3sz","title":"Phase 1.3: Domain Services","description":"# Phase 1.3: Domain Services\n\n## Overview\nImplement higher-level services that build on the Core Data Layer: variable resolution, tag/category management, workflow storage, and import/export services.\n\n## Why This Matters (Strategic Context)\nThese services encapsulate business logic that's reused across the ENTIRE app:\n\n| Service | Used In |\n|---------|---------|\n| VariableResolver | Editor preview, Menu bar copy, Workflow runner |\n| TagStore/CategoryStore | Sidebar, Pickers, Search filters |\n| WorkflowStore | Workflow builder, Runner, Deletion checks |\n| ImportService | File menu, Drag-drop, Bulk operations |\n| ExportService | File menu, Backup, Library sharing |\n\nBuilding these as standalone services (not embedded in UI) enables:\n- Unit testing without UI\n- Reuse across Menu Bar and Main Window\n- Future CLI access to same logic\n\n## Key Components\n\n### VariableResolver (Most Complex)\nParses and resolves `{{variables}}` in prompts.\n\n**Grammar Specification (From plan.md §5.5):**\n- Token form: `{{ name }}` (whitespace allowed)\n- Name regex: `[A-Za-z_][A-Za-z0-9_.-]*`\n- Optional default: `{{name=default value}}`\n- Escaping: `\\{{` renders literal `{{`\n- Scope: Markdown body only (exclude YAML front matter)\n\n**Critical Edge Cases:**\n| Input | Behavior | Rationale |\n|-------|----------|-----------|\n| `{{name=has }} more}}` | Default = `has ` | First `}}` wins (greedy) |\n| `{{outer={{inner}}}}` | Name = `outer={{inner` | First `}}` wins |\n| `{{}}` or `{{ }}` | Literal text | Invalid: empty name |\n| `{{name` | Literal text | Invalid: unclosed |\n| `{{name=}}` | Valid, empty default | Explicit empty |\n| `{{123name}}` | Literal text | Invalid: starts with digit |\n\n**Parser Behavior:**\n- Invalid syntax → treat as literal text (no error thrown)\n- Log warning for invalid tokens (helps debug templates)\n- Never throw on malformed input\n\n### TagStore / CategoryStore\n- CRUD for tags and categories\n- Case-insensitive uniqueness (via COLLATE NOCASE index)\n- Orphan cleanup (tags with 0 prompts) — optional enhancement\n\n### WorkflowStore\n- Workflow CRUD with step ordering\n- Sort by `order_index ASC, id` for stability\n- Allow gaps in order_index (simplifies drag-drop)\n- Check prompt references before deletion\n\n### ImportService\nSingle file and bulk folder import with conflict resolution.\n\n**ID Conflict Resolution (From plan.md §2.4):**\nWhen imported file has ID that already exists:\n1. Single import: Dialog with options\n   - **Import as Copy** (default): New UUID, log mapping\n   - **Replace Existing**: Overwrite\n   - **Skip**: Don't import\n2. Bulk import: Same + \"Apply to all\" checkbox\n\n**Edge Cases:**\n- No ID in front matter → generate new UUID\n- Malformed ID → treat as no ID, log warning\n- Track old→new UUID mapping in ImportResult\n\n### ExportService\n- Single prompt as .md\n- Full library as .zip with:\n  - prompts/ directory\n  - metadata.json (for reimport)\n  - README.md (human-readable index)\n- Preserve all metadata for round-trip\n\n## Testing Requirements\n- **95%+ coverage on VariableResolver** — Edge cases are critical\n- 90%+ coverage on WorkflowStore\n- 85%+ coverage on Import/Export\n- Round-trip test: export → import preserves everything\n\n## This Epic Blocks\n- Phase 1.4 Main Window UI (needs services)\n- Phase 1.5 Menu Bar (needs VariableResolver)\n- Phase 1.6 Workflows (needs WorkflowStore)\n- Phase 1.7 Import/Export UI (needs services)\n\n## This Epic Requires\n- Phase 1.2 Core Data Layer complete\n\n## References\n- docs/plans/plan.md §5.5 VariableResolver\n- docs/plans/plan.md §5.6 WorkflowStore\n- docs/plans/plan.md §2.4 Import ID conflict resolution","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-22T03:13:35.512799Z","created_by":"mjefferson","updated_at":"2026-01-22T03:15:38.281980Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-3sz","depends_on_id":"pho-1qw","type":"parent-child","created_at":"2026-01-22T03:13:35.513244Z","created_by":"mjefferson"},{"issue_id":"pho-3sz","depends_on_id":"pho-3n0","type":"blocks","created_at":"2026-01-22T03:15:38.281967Z","created_by":"mjefferson"}]}
{"id":"pho-3uf","title":"Build VariableResolverSheet for menu bar","description":"# Build VariableResolverSheet\n\n## Overview\nWhen user selects a prompt with variables, show an inline form to fill values before copying.\n\n## Why This Matters\nThe power of variables is instant customization:\n- Select \"Code Review for {{language}}\"\n- Fill in \"Swift\"\n- Copy resolved prompt\n\nThis must be fast and inline—no opening main app.\n\n## Implementation\n```swift\nstruct VariableResolverSheet: View {\n    let prompt: Prompt\n    let onCopy: (String) -> Void\n    let onCancel: () -> Void\n    \n    @State private var values: [String: String] = [:]\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 12) {\n            Text(\"Fill Variables\")\n                .font(.headline)\n            \n            ForEach(prompt.variables) { variable in\n                HStack {\n                    Text(variable.id)\n                        .frame(width: 100, alignment: .trailing)\n                    \n                    if variable.id.lowercased().contains(\"context\") ||\n                       variable.id.lowercased().contains(\"content\") {\n                        // Multi-line for context/content\n                        TextEditor(text: binding(for: variable))\n                            .frame(height: 60)\n                            .border(Color.secondary.opacity(0.3))\n                    } else {\n                        TextField(\n                            variable.defaultValue ?? \"\",\n                            text: binding(for: variable)\n                        )\n                    }\n                }\n            }\n            \n            HStack {\n                Spacer()\n                Button(\"Cancel\") { onCancel() }\n                    .keyboardShortcut(.escape)\n                Button(\"Copy\") { copyResolved() }\n                    .keyboardShortcut(.return)\n                    .buttonStyle(.borderedProminent)\n            }\n        }\n        .padding()\n        .frame(width: 350)\n        .onAppear { initializeDefaults() }\n    }\n    \n    private func binding(for variable: PromptVariable) -> Binding<String> {\n        Binding(\n            get: { values[variable.id] ?? variable.defaultValue ?? \"\" },\n            set: { values[variable.id] = $0 }\n        )\n    }\n    \n    private func initializeDefaults() {\n        for variable in prompt.variables {\n            if values[variable.id] == nil {\n                values[variable.id] = variable.defaultValue ?? \"\"\n            }\n        }\n    }\n    \n    private func copyResolved() {\n        let resolver = VariableResolver()\n        let resolved = resolver.resolve(content: prompt.content, values: values)\n        onCopy(resolved)\n    }\n}\n```\n\n## Integration with QuickSearch\n```swift\n// In MenuBarViewModel\nfunc selectResult(_ result: PromptSummary) {\n    Task {\n        let prompt = try await promptStore.fetch(id: result.id)!\n        \n        if prompt.variables.isEmpty {\n            // No variables - copy immediately\n            copyToClipboard(prompt.content)\n            closePopover()\n        } else {\n            // Has variables - show resolver sheet\n            showVariableSheet = true\n            selectedPrompt = prompt\n        }\n    }\n}\n```\n\n## UX Flow\n1. User selects prompt with variables\n2. Sheet appears with form fields\n3. Defaults pre-populated\n4. Tab between fields\n5. Enter or click Copy\n6. Resolved prompt copied\n7. Popover closes\n\n## Acceptance Criteria\n- [ ] Sheet appears for prompts with variables\n- [ ] Default values pre-populated\n- [ ] Tab navigates between fields\n- [ ] Multi-line fields for context/content\n- [ ] Enter copies and closes\n- [ ] Escape cancels\n- [ ] Resolved content correct\n- [ ] Clipboard contains resolved prompt","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:26:11.588434Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:26.708110Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-3uf","depends_on_id":"pho-1rs","type":"blocks","created_at":"2026-01-22T03:27:26.708098Z","created_by":"mjefferson"},{"issue_id":"pho-3uf","depends_on_id":"pho-30e","type":"parent-child","created_at":"2026-01-22T03:26:11.588865Z","created_by":"mjefferson"}]}
{"id":"pho-3uh","title":"Create SPM package structure","description":"# Create SPM Package Structure\n\n## Overview\nInitialize the Swift Package Manager structure with the multi-target layout that supports both the GUI app and future CLI.\n\n## Why This Structure Matters\nThe separation into PromptHoarderCore + PromptHoarder is a strategic architecture decision:\n\n1. **Core logic shared between GUI and CLI (Phase 2)**\n   - PromptStore, VaultManager, VariableResolver all live in Core\n   - CLI can import Core without pulling in SwiftUI\n\n2. **Cleaner dependency management**\n   - Core has NO UI dependencies (no AppKit, no SwiftUI)\n   - App depends on Core + UI-specific deps (Sparkle)\n\n3. **Better testability**\n   - Core can be unit tested without launching the app\n   - Tests run faster, more reliably in CI\n\n## Deliverables\n\n### Package.swift\n```swift\n// swift-tools-version: 6.0\nimport PackageDescription\n\nlet package = Package(\n    name: \"PromptHoarder\",\n    platforms: [.macOS(.v14)],\n    products: [\n        .library(name: \"PromptHoarderCore\", targets: [\"PromptHoarderCore\"]),\n        .executable(name: \"PromptHoarder\", targets: [\"PromptHoarder\"]),\n    ],\n    dependencies: [\n        // Added in next task\n    ],\n    targets: [\n        .target(name: \"PromptHoarderCore\", dependencies: [...]),\n        .executableTarget(name: \"PromptHoarder\", dependencies: [\"PromptHoarderCore\", ...]),\n        .testTarget(name: \"PromptHoarderCoreTests\", dependencies: [\"PromptHoarderCore\"]),\n        .testTarget(name: \"PromptHoarderTests\", dependencies: [\"PromptHoarder\"]),\n    ]\n)\n```\n\n### Directory Structure\n```\nSources/\n├── PromptHoarderCore/\n│   ├── Models/         # Prompt, Workflow, Tag, Category\n│   ├── Storage/        # GRDB, VaultManager, DatabaseManager\n│   ├── Services/       # VariableResolver, ImportService, etc.\n│   └── Utilities/      # Logging, Extensions\n└── PromptHoarder/\n    ├── App/            # PromptHoarderApp.swift, AppState\n    ├── Views/          # All SwiftUI views\n    ├── ViewModels/     # @Observable view models\n    ├── MenuBar/        # Menu bar specific code\n    └── Resources/      # Assets, Info.plist\nTests/\n├── PromptHoarderCoreTests/\n└── PromptHoarderTests/\n```\n\n## Technical Notes\n- Use `.executableTarget` for the app (produces runnable .app)\n- `platforms: [.macOS(.v14)]` enforces Sonoma minimum\n- Consider adding Scripts/ directory for tooling\n\n## Acceptance Criteria\n- [ ] `swift build` succeeds (with placeholder files)\n- [ ] `swift test` runs (even if no tests yet)\n- [ ] Directory structure matches plan exactly\n- [ ] Package.swift has correct target definitions\n\n## This Task Blocks\n- All other Phase 1.1 tasks\n\n## References\n- docs/plans/plan.md §2.1 Module Structure","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:16:29.645665Z","created_by":"mjefferson","updated_at":"2026-01-22T03:16:29.646062Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-3uh","depends_on_id":"pho-1zt","type":"parent-child","created_at":"2026-01-22T03:16:29.646050Z","created_by":"mjefferson"}]}
{"id":"pho-8p4","title":"Implement WorkflowStore","description":"# Implement WorkflowStore\n\n## Overview\nCRUD operations for workflows with step ordering and dependency checking.\n\n## Why This Matters\nWorkflows are multi-step prompt sequences. The store must:\n- Maintain step order (order_index)\n- Check prompt references before deletion\n- Support drag-drop reordering efficiently\n\n## Protocol Definition (From plan.md §5.6)\n```swift\nprotocol WorkflowStoring: Sendable {\n    func fetchAll() async throws -> [Workflow]\n    func fetch(id: UUID) async throws -> Workflow?\n    func save(_ workflow: Workflow) async throws\n    func delete(id: UUID) async throws\n    func workflowsReferencing(promptId: UUID) async throws -> [WorkflowReference]\n}\n\nstruct WorkflowReference: Sendable {\n    let workflowId: UUID\n    let workflowTitle: String\n    let stepCount: Int  // How many steps reference this prompt\n}\n```\n\n## Step Ordering Design\n\n### Why Gaps Are Allowed\nThe `order_index` allows gaps (e.g., 0, 5, 10) to simplify drag-drop:\n- Insert between 0 and 5 → use 2 or 3\n- No need to renumber all rows on every drag\n\n### Sorting Rule\n```swift\n// ORDER BY order_index ASC, id ASC\n// Ties broken by id for determinism\n```\n\n### Optional Compaction\nOn save, optionally compact to 0, 1, 2, ...:\n```swift\nfunc save(_ workflow: Workflow) async throws {\n    var compactedSteps = workflow.steps\n    for (index, step) in compactedSteps.enumerated() {\n        compactedSteps[index].orderIndex = index * 10  // Leave gaps\n    }\n    // ... save\n}\n```\n\n## Implementation\n```swift\nactor WorkflowStore: WorkflowStoring {\n    private let dbQueue: DatabaseQueue\n    \n    func fetchAll() async throws -> [Workflow] {\n        try await dbQueue.read { db in\n            let records = try WorkflowRecord\n                .including(all: WorkflowRecord.steps\n                    .order(Column(\"order_index\"), Column(\"id\")))\n                .including(all: WorkflowRecord.tags)\n                .fetchAll(db)\n            return records.map { $0.toWorkflow() }\n        }\n    }\n    \n    func save(_ workflow: Workflow) async throws {\n        try await dbQueue.write { db in\n            // Upsert workflow\n            var record = WorkflowRecord(from: workflow)\n            try record.save(db)\n            \n            // Delete existing steps\n            try WorkflowStepRecord\n                .filter(Column(\"workflow_id\") == workflow.id.uuidString)\n                .deleteAll(db)\n            \n            // Insert new steps\n            for (index, step) in workflow.steps.enumerated() {\n                var stepRecord = WorkflowStepRecord(from: step)\n                stepRecord.orderIndex = index * 10\n                try stepRecord.insert(db)\n            }\n        }\n    }\n    \n    func delete(id: UUID) async throws {\n        try await dbQueue.write { db in\n            // Steps are CASCADE deleted\n            try WorkflowRecord.deleteOne(db, key: id.uuidString)\n        }\n    }\n    \n    func workflowsReferencing(promptId: UUID) async throws -> [WorkflowReference] {\n        try await dbQueue.read { db in\n            let sql = \"\"\"\n                SELECT w.id, w.title, COUNT(*) as step_count\n                FROM workflow_steps ws\n                JOIN workflows w ON ws.workflow_id = w.id\n                WHERE ws.prompt_id = ?\n                GROUP BY w.id, w.title\n            \"\"\"\n            \n            return try Row.fetchAll(db, sql: sql, arguments: [promptId.uuidString])\n                .map { row in\n                    WorkflowReference(\n                        workflowId: UUID(uuidString: row[\"id\"])!,\n                        workflowTitle: row[\"title\"],\n                        stepCount: row[\"step_count\"]\n                    )\n                }\n        }\n    }\n}\n```\n\n## Step Data Model\n```swift\nstruct WorkflowStep: Identifiable, Codable, Equatable, Sendable {\n    let id: UUID\n    var promptId: UUID\n    var orderIndex: Int\n    var stepNotes: String?\n    var variableOverrides: [String: String]  // Stored as JSON\n}\n```\n\n## Variable Overrides\nEach step can override variable defaults:\n```swift\n// Step-level overrides\nlet step = WorkflowStep(\n    id: UUID(),\n    promptId: promptId,\n    orderIndex: 0,\n    stepNotes: \"Use for Swift code\",\n    variableOverrides: [\"language\": \"Swift\"]\n)\n\n// When running workflow, merge:\nlet values = prompt.defaultValues.merging(step.variableOverrides) { _, new in new }\nlet resolved = variableResolver.resolve(prompt.content, values: values)\n```\n\n## Acceptance Criteria\n- [ ] CRUD operations work\n- [ ] Steps ordered correctly (order_index, then id)\n- [ ] Steps deleted when workflow deleted (CASCADE)\n- [ ] workflowsReferencing finds all referencing workflows\n- [ ] Variable overrides stored as JSON\n- [ ] Drag-drop reordering works (gaps allowed)\n- [ ] Unit tests for all operations\n\n## References\n- docs/plans/plan.md §5.6 WorkflowStore\n- docs/plans/plan.md §4.1 workflow_steps schema","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:24:31.191603Z","created_by":"mjefferson","updated_at":"2026-01-22T03:24:31.191996Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-8p4","depends_on_id":"pho-3sz","type":"parent-child","created_at":"2026-01-22T03:24:31.191986Z","created_by":"mjefferson"}]}
{"id":"pho-8y9","title":"Write storage layer unit tests","description":"# Write Storage Layer Unit Tests\n\n## Overview\nComprehensive unit tests for the Core Data Layer: PromptStore, VaultManager, DatabaseManager, and FileWatcher.\n\n## Why This Matters\nThe storage layer is the foundation. Bugs here mean data loss. Testing requirements:\n- 90%+ coverage on PromptStore\n- 85%+ coverage on VaultManager\n- All edge cases from plan.md tested\n\n## Test Structure\n\n### PromptStoreTests\n```swift\nfinal class PromptStoreTests: XCTestCase {\n    var store: PromptStore!\n    var tempDir: URL!\n    \n    override func setUp() async throws {\n        tempDir = FileManager.default.temporaryDirectory\n            .appendingPathComponent(UUID().uuidString)\n        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)\n        \n        // Create in-memory database for testing\n        store = try await PromptStore(vaultURL: tempDir, inMemory: true)\n    }\n    \n    // CRUD Tests\n    func testCreatePrompt() async throws\n    func testFetchPromptById() async throws\n    func testUpdatePrompt() async throws\n    func testDeletePrompt() async throws\n    func testArchivePrompt() async throws\n    \n    // Search Tests\n    func testSearchByTitle() async throws\n    func testSearchByContent() async throws\n    func testSearchWithTagFilter() async throws\n    func testSearchWithCategoryFilter() async throws\n    func testSearchFavoritesOnly() async throws\n    func testSearchExcludesArchived() async throws\n    func testSearchIncludesArchived() async throws\n    \n    // FTS Tests\n    func testFTSRanking() async throws  // More relevant results first\n    func testFTSPrefixMatching() async throws\n    func testFTSMultipleTerms() async throws\n    \n    // Deletion Protection Tests\n    func testDeleteBlockedWhenInWorkflow() async throws\n    func testDeleteAllowedWhenNotInWorkflow() async throws\n    func testArchiveAllowedWhenInWorkflow() async throws\n    \n    // Performance Tests\n    func testSearchPerformanceWith5000Prompts() async throws\n}\n```\n\n### VaultManagerTests\n```swift\nfinal class VaultManagerTests: XCTestCase {\n    // Atomic Write Tests\n    func testAtomicWriteSuccess() async throws\n    func testAtomicWriteCrossVolume() async throws  // Temp in same dir\n    func testCaseOnlyRename() async throws          // Foo.md → foo.md\n    func testWriteFailsOnDiskFull() async throws\n    func testWriteFailsOnPermissionDenied() async throws\n    func testWriteRetriesOnLockedFile() async throws\n    \n    // Scan Tests\n    func testScanDetectsNewFiles() async throws\n    func testScanDetectsModifiedFiles() async throws\n    func testScanDetectsDeletedFiles() async throws\n    func testScanIgnoresICloudPlaceholders() async throws\n    func testScanIgnoresSwapFiles() async throws\n    func testScanIgnoresConflictedCopies() async throws\n    func testScanIgnoresDSStore() async throws\n    \n    // Content Hashing Tests\n    func testHashConsistency() async throws\n    func testHashChangesOnModification() async throws\n}\n```\n\n### DatabaseManagerTests\n```swift\nfinal class DatabaseManagerTests: XCTestCase {\n    func testInitializeCreatesDatabase() async throws\n    func testMigrationsRunInOrder() async throws\n    func testRebuildRecreatesFromVault() async throws\n    func testRebuildProgressReporting() async throws\n    func testRebuildHandlesEmptyVault() async throws\n    func testCloseReleasesResources() async throws\n}\n```\n\n### FileWatcherTests\n```swift\nfinal class FileWatcherTests: XCTestCase {\n    func testDetectsModification() async throws\n    func testDetectsDeletion() async throws\n    func testDebouncesRapidChanges() async throws\n    func testStopWatchingCleansUp() async throws\n    func testMultipleFilesWatched() async throws\n}\n```\n\n### SyncLogicTests\n```swift\nfinal class SyncLogicTests: XCTestCase {\n    func testLaunchSyncAddsNewFiles() async throws\n    func testLaunchSyncUpdatesModifiedFiles() async throws\n    func testLaunchSyncRemovesDeletedFiles() async throws\n    func testSaveWritesFileBeforeDB() async throws\n    func testSaveDetectsExternalChange() async throws\n    func testConflictResolutionKeepMine() async throws\n    func testConflictResolutionUseDisk() async throws\n    func testConflictResolutionDuplicate() async throws\n}\n```\n\n## Test Utilities\n\n### InMemory Database\n```swift\nextension PromptStore {\n    static func inMemory() async throws -> PromptStore {\n        let dbQueue = try DatabaseQueue()\n        // Run migrations\n        return PromptStore(dbQueue: dbQueue, vaultManager: MockVaultManager())\n    }\n}\n```\n\n### Mock VaultManager\n```swift\nclass MockVaultManager: VaultManaging {\n    var files: [UUID: String] = [:]\n    var writeDelay: TimeInterval = 0\n    var shouldFailWrite = false\n    \n    func readPromptContent(id: UUID) async throws -> String {\n        guard let content = files[id] else {\n            throw VaultError.fileNotFound\n        }\n        return content\n    }\n    \n    func writePromptContent(id: UUID, content: String) async throws {\n        if shouldFailWrite { throw WriteError.permissionDenied(...) }\n        if writeDelay > 0 { try await Task.sleep(for: .seconds(writeDelay)) }\n        files[id] = content\n    }\n}\n```\n\n### Test Fixtures\n```swift\nenum TestFixtures {\n    static let samplePrompt = Prompt(\n        id: UUID(),\n        title: \"Test Prompt\",\n        content: \"Hello {{name}}!\",\n        tags: [Tag(id: UUID(), name: \"test\")],\n        category: nil,\n        isFavorite: false,\n        isArchived: false,\n        createdAt: Date(),\n        updatedAt: Date(),\n        usageCount: 0,\n        lastUsedAt: nil\n    )\n    \n    static let sampleMarkdown = \"\"\"\n    ---\n    id: \\(samplePrompt.id.uuidString)\n    title: Test Prompt\n    tags: [test]\n    ---\n    \n    Hello {{name}}!\n    \"\"\"\n}\n```\n\n## Coverage Targets\n| Component | Target | Focus Areas |\n|-----------|--------|-------------|\n| PromptStore | 90% | CRUD, FTS, deletion protection |\n| VaultManager | 85% | Atomic writes, scan, edge cases |\n| DatabaseManager | 80% | Lifecycle, rebuild |\n| FileWatcher | 75% | Event detection, debounce |\n| SyncLogic | 85% | Conflict resolution |\n\n## Acceptance Criteria\n- [ ] All test files created and organized\n- [ ] 90%+ coverage on PromptStore\n- [ ] 85%+ coverage on VaultManager\n- [ ] All edge cases from plan.md have tests\n- [ ] Tests run in <30 seconds total\n- [ ] No flaky tests\n- [ ] CI integration configured\n\n## References\n- docs/plans/plan.md §8 Testing Strategy\n- docs/plans/plan.md §2.4 Edge cases","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:21:34.464643Z","created_by":"mjefferson","updated_at":"2026-01-22T03:21:45.387222Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-8y9","depends_on_id":"pho-1u7","type":"blocks","created_at":"2026-01-22T03:21:45.356564Z","created_by":"mjefferson"},{"issue_id":"pho-8y9","depends_on_id":"pho-2td","type":"blocks","created_at":"2026-01-22T03:21:45.387210Z","created_by":"mjefferson"},{"issue_id":"pho-8y9","depends_on_id":"pho-3km","type":"blocks","created_at":"2026-01-22T03:21:45.371634Z","created_by":"mjefferson"},{"issue_id":"pho-8y9","depends_on_id":"pho-3n0","type":"parent-child","created_at":"2026-01-22T03:21:34.465279Z","created_by":"mjefferson"}]}
{"id":"pho-cuv","title":"Test Prefix","status":"tombstone","priority":3,"issue_type":"task","created_at":"2026-01-22T03:11:35.464346Z","created_by":"mjefferson","updated_at":"2026-01-22T03:11:39.914384Z","deleted_at":"2026-01-22T03:11:39.914379Z","deleted_by":"mjefferson","delete_reason":"delete","original_type":"task","compaction_level":0,"original_size":0}
{"id":"pho-kk1","title":"Implement SQLite schema and migrations","description":"# Implement SQLite Schema and Migrations\n\n## Overview\nDefine the complete SQLite schema using GRDB and set up the migration system for future schema changes.\n\n## Why This Matters\nThe schema is the foundation of all data operations. Getting it right now prevents painful migrations later.\n\n## Schema Design (From plan.md §4.1)\n\n### prompts table\n```sql\nCREATE TABLE prompts (\n    sqlite_id INTEGER PRIMARY KEY,          -- For FTS content_rowid\n    id TEXT NOT NULL UNIQUE,                -- UUID (app-level ID)\n    title TEXT NOT NULL,\n    file_path TEXT NOT NULL UNIQUE,         -- Relative to vault\n    category_id TEXT,                       -- FK to categories\n    is_favorite INTEGER NOT NULL DEFAULT 0,\n    is_archived INTEGER NOT NULL DEFAULT 0,\n    content_hash TEXT NOT NULL,             -- SHA256 of file\n    body_cache TEXT NOT NULL,               -- Plain text for FTS\n    created_at TEXT NOT NULL,               -- ISO8601\n    updated_at TEXT NOT NULL,\n    usage_count INTEGER NOT NULL DEFAULT 0,\n    last_used_at TEXT,\n    FOREIGN KEY (category_id) REFERENCES categories(id)\n);\n```\n\n**Why sqlite_id AND id?**\n- FTS5 requires integer rowid for content mapping\n- UUIDs enable import/export without collisions\n- sqlite_id is ephemeral (changes on rebuild), id is stable\n\n### tags table\n```sql\nCREATE TABLE tags (\n    id TEXT PRIMARY KEY,\n    name TEXT NOT NULL\n);\nCREATE UNIQUE INDEX tags_name_nocase ON tags(name COLLATE NOCASE);\n```\n\n### prompt_tags (many-to-many)\n```sql\nCREATE TABLE prompt_tags (\n    prompt_id TEXT NOT NULL,\n    tag_id TEXT NOT NULL,\n    PRIMARY KEY (prompt_id, tag_id),\n    FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE CASCADE,\n    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE\n);\n```\n\n### categories table\n```sql\nCREATE TABLE categories (\n    id TEXT PRIMARY KEY,\n    name TEXT NOT NULL\n);\nCREATE UNIQUE INDEX categories_name_nocase ON categories(name COLLATE NOCASE);\n```\n\n### workflows table\n```sql\nCREATE TABLE workflows (\n    id TEXT PRIMARY KEY,\n    title TEXT NOT NULL,\n    description TEXT,\n    created_at TEXT NOT NULL,\n    updated_at TEXT NOT NULL\n);\n```\n\n### workflow_steps table\n```sql\nCREATE TABLE workflow_steps (\n    id TEXT PRIMARY KEY,\n    workflow_id TEXT NOT NULL,\n    prompt_id TEXT NOT NULL,\n    order_index INTEGER NOT NULL,\n    step_notes TEXT,\n    variable_overrides TEXT,  -- JSON\n    FOREIGN KEY (workflow_id) REFERENCES workflows(id) ON DELETE CASCADE,\n    FOREIGN KEY (prompt_id) REFERENCES prompts(id) ON DELETE RESTRICT\n);\n```\n\n**Why ON DELETE RESTRICT on prompt_id?**\nPrevents deleting prompts that are part of workflows. App must handle gracefully.\n\n### FTS5 index\n```sql\nCREATE VIRTUAL TABLE prompts_fts USING fts5(\n    title, body_cache,\n    content='prompts',\n    content_rowid='sqlite_id'\n);\n```\n\n### FTS Sync Triggers\n```sql\nCREATE TRIGGER prompts_ai AFTER INSERT ON prompts BEGIN\n    INSERT INTO prompts_fts(rowid, title, body_cache)\n    VALUES (NEW.sqlite_id, NEW.title, NEW.body_cache);\nEND;\n-- Plus UPDATE and DELETE triggers (see plan.md)\n```\n\n## GRDB Implementation\n\n### Record Types\n```swift\nstruct PromptRecord: Codable, PersistableRecord, FetchableRecord {\n    static let databaseTableName = \"prompts\"\n    \n    var sqliteId: Int64?  // Auto-assigned\n    let id: String        // UUID as string\n    var title: String\n    // ...\n}\n```\n\n### Migration System\n```swift\nvar migrator = DatabaseMigrator()\n\nmigrator.registerMigration(\"v1_initial\") { db in\n    // Create all tables and indices\n}\n\n// Future migrations added here:\n// migrator.registerMigration(\"v2_something\") { db in ... }\n```\n\n## Acceptance Criteria\n- [ ] All tables created with correct schema\n- [ ] FTS5 virtual table created\n- [ ] Triggers keep FTS in sync\n- [ ] Indices created for common queries\n- [ ] GRDB Record types defined\n- [ ] Migration v1 registered and runs\n- [ ] Unit tests for schema creation\n\n## References\n- docs/plans/plan.md §4.1 SQLite Schema\n- GRDB documentation: https://github.com/groue/GRDB.swift","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:18:14.836451Z","created_by":"mjefferson","updated_at":"2026-01-22T03:18:14.836830Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-kk1","depends_on_id":"pho-3n0","type":"parent-child","created_at":"2026-01-22T03:18:14.836820Z","created_by":"mjefferson"}]}
{"id":"pho-knf","title":"Build PromptListView with search and filtering","description":"# Build PromptListView\n\n## Overview\nList of prompts with search, filtering, and selection. Uses PromptSummary for performance.\n\n## Why PromptSummary?\nLoading full prompt content for 500+ items would be slow. PromptSummary is DB-only (no file reads), making list rendering <100ms.\n\n## Implementation\n```swift\nstruct PromptListView: View {\n    let section: SidebarSection?\n    @Binding var selection: UUID?\n    @Environment(LibraryViewModel.self) private var viewModel\n    \n    var body: some View {\n        List(viewModel.filteredPrompts, selection: $selection) { summary in\n            PromptRowView(summary: summary)\n        }\n        .searchable(text: $viewModel.searchQuery)\n        .onChange(of: section) { _, newSection in\n            viewModel.updateFilter(for: newSection)\n        }\n    }\n}\n\nstruct PromptRowView: View {\n    let summary: PromptSummary\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 4) {\n            HStack {\n                Text(summary.title)\n                    .font(.headline)\n                if summary.isFavorite {\n                    Image(systemName: \"star.fill\")\n                        .foregroundColor(.yellow)\n                }\n                Spacer()\n            }\n            \n            HStack(spacing: 8) {\n                ForEach(summary.tags.prefix(3)) { tag in\n                    Text(tag.name)\n                        .font(.caption)\n                        .padding(.horizontal, 6)\n                        .padding(.vertical, 2)\n                        .background(Color.secondary.opacity(0.2))\n                        .cornerRadius(4)\n                }\n                if summary.tags.count > 3 {\n                    Text(\"+\\(summary.tags.count - 3)\")\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n            }\n        }\n        .padding(.vertical, 4)\n    }\n}\n```\n\n## Sort Options\n```swift\nenum SortOption: String, CaseIterable {\n    case updatedAt = \"Date Modified\"\n    case title = \"Title\"\n    case usageCount = \"Most Used\"\n}\n```\n\n## Performance Target\n- List rendering: <100ms for 500+ items\n- Search debounce: 100ms\n\n## Acceptance Criteria\n- [ ] List renders prompts\n- [ ] Search filters results in real-time\n- [ ] Section filtering works\n- [ ] Selection binds correctly\n- [ ] Favorite indicator shows\n- [ ] Tags display (max 3 + overflow)\n- [ ] Sort options work\n- [ ] Performance: <100ms render","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:26:11.517599Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:26.669885Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-knf","depends_on_id":"pho-24o","type":"parent-child","created_at":"2026-01-22T03:26:11.517984Z","created_by":"mjefferson"},{"issue_id":"pho-knf","depends_on_id":"pho-2vd","type":"blocks","created_at":"2026-01-22T03:27:26.669872Z","created_by":"mjefferson"}]}
{"id":"pho-lrw","title":"Build PromptDetailView and PromptEditorView","description":"# Build PromptDetailView and PromptEditorView\n\n## Overview\nDetail view shows read-only prompt, editor view allows editing with live preview.\n\n## PromptDetailView (Read Mode)\n```swift\nstruct PromptDetailView: View {\n    let promptId: UUID\n    @State private var prompt: Prompt?\n    @State private var isEditing = false\n    @Environment(PromptDetailViewModel.self) private var viewModel\n    \n    var body: some View {\n        Group {\n            if let prompt {\n                ScrollView {\n                    VStack(alignment: .leading, spacing: 16) {\n                        // Header\n                        HStack {\n                            Text(prompt.title)\n                                .font(.largeTitle)\n                            Spacer()\n                            Button(action: toggleFavorite) {\n                                Image(systemName: prompt.isFavorite ? \"star.fill\" : \"star\")\n                            }\n                        }\n                        \n                        // Rendered content\n                        MarkdownPreviewView(content: prompt.content)\n                        \n                        Divider()\n                        \n                        // Metadata\n                        MetadataView(prompt: prompt)\n                        \n                        // Actions\n                        HStack {\n                            Button(\"Edit\") { isEditing = true }\n                            Button(\"Copy\") { copyToClipboard() }\n                            Button(\"Use\") { usePrompt() }\n                        }\n                    }\n                    .padding()\n                }\n                .sheet(isPresented: $isEditing) {\n                    PromptEditorView(prompt: $prompt)\n                }\n            } else {\n                ProgressView()\n            }\n        }\n        .task { await loadPrompt() }\n    }\n}\n```\n\n## PromptEditorView (Edit Mode)\n```swift\nstruct PromptEditorView: View {\n    @Binding var prompt: Prompt?\n    @State private var editingTitle: String = \"\"\n    @State private var editingContent: String = \"\"\n    @State private var showPreview = false\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        NavigationStack {\n            HSplitView {\n                // Editor\n                VStack {\n                    TextField(\"Title\", text: $editingTitle)\n                        .font(.title)\n                    \n                    TextEditor(text: $editingContent)\n                        .font(.body.monospaced())\n                }\n                .frame(minWidth: 300)\n                \n                // Preview (optional)\n                if showPreview {\n                    MarkdownPreviewView(content: editingContent)\n                        .frame(minWidth: 300)\n                }\n            }\n            .toolbar {\n                ToolbarItem(placement: .cancellationAction) {\n                    Button(\"Cancel\") { dismiss() }\n                }\n                ToolbarItem(placement: .confirmationAction) {\n                    Button(\"Save\") { save() }\n                }\n                ToolbarItem {\n                    Toggle(isOn: $showPreview) {\n                        Image(systemName: \"eye\")\n                    }\n                }\n            }\n            .navigationTitle(\"Edit Prompt\")\n        }\n        .frame(minWidth: 600, minHeight: 400)\n    }\n}\n```\n\n## Variable Highlighting\nHighlight `{{variables}}` in the editor:\n```swift\n// Use AttributedString or custom TextEditor\n// Variables shown in blue/different color\n```\n\n## Acceptance Criteria\n- [ ] Detail view loads and displays prompt\n- [ ] Markdown renders correctly\n- [ ] Favorite toggle works\n- [ ] Edit button opens editor\n- [ ] Editor saves changes\n- [ ] Live preview toggle works\n- [ ] Variable highlighting visible\n- [ ] Tag/category editing works\n- [ ] Unsaved changes warning","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:26:11.540405Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:26.689373Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-lrw","depends_on_id":"pho-24o","type":"parent-child","created_at":"2026-01-22T03:26:11.540803Z","created_by":"mjefferson"},{"issue_id":"pho-lrw","depends_on_id":"pho-knf","type":"blocks","created_at":"2026-01-22T03:27:26.689361Z","created_by":"mjefferson"}]}
{"id":"pho-tsy","title":"Implement FileWatcher","description":"# Implement FileWatcher\n\n## Overview\nMonitors open files for external changes using DispatchSource. Enables real-time conflict detection when a file is modified by another process.\n\n## Why This Matters\nUsers may edit prompt files in external editors (VS Code, Obsidian, etc.). Without detection:\n- User edits in app, external edit happens, user saves → external edit lost\n- Silent data loss violates our \"no silent data loss\" principle\n\nFileWatcher enables the conflict UI: \"File changed on disk. [Reload] [Ignore]\"\n\n## Protocol Definition (From plan.md §5.4)\n```swift\nprotocol FileWatching: Sendable {\n    func watch(url: URL, onChange: @escaping @Sendable (FileChangeEvent) -> Void) -> FileWatchToken\n    func stopWatching(_ token: FileWatchToken)\n}\n\nstruct FileWatchToken: Sendable {\n    let id: UUID\n    let url: URL\n}\n\nenum FileChangeEvent: Sendable {\n    case modified\n    case deleted\n    case renamed(newURL: URL)\n}\n```\n\n## Implementation Using DispatchSource\n\n```swift\nactor FileWatcher: FileWatching {\n    private var watchers: [UUID: WatcherState] = [:]\n    \n    private struct WatcherState {\n        let fileDescriptor: Int32\n        let source: DispatchSourceFileSystemObject\n        let debounceTask: Task<Void, Never>?\n    }\n    \n    func watch(url: URL, onChange: @escaping @Sendable (FileChangeEvent) -> Void) -> FileWatchToken {\n        let tokenId = UUID()\n        let path = url.path\n        \n        // Open file descriptor for monitoring\n        let fd = open(path, O_EVTONLY)\n        guard fd >= 0 else {\n            // File doesn't exist or can't be opened\n            return FileWatchToken(id: tokenId, url: url)\n        }\n        \n        // Create dispatch source\n        let source = DispatchSource.makeFileSystemObjectSource(\n            fileDescriptor: fd,\n            eventMask: [.write, .delete, .rename],\n            queue: .global(qos: .utility)\n        )\n        \n        // Debounce handler (100ms)\n        var debounceTask: Task<Void, Never>?\n        \n        source.setEventHandler { [weak self] in\n            let flags = source.data\n            \n            // Cancel previous debounce\n            debounceTask?.cancel()\n            \n            // Debounce: wait 100ms before firing\n            debounceTask = Task {\n                try? await Task.sleep(nanoseconds: 100_000_000)  // 100ms\n                \n                guard !Task.isCancelled else { return }\n                \n                let event: FileChangeEvent\n                if flags.contains(.delete) {\n                    event = .deleted\n                } else if flags.contains(.rename) {\n                    // Try to find new path (if still exists)\n                    event = .renamed(newURL: url)  // simplified\n                } else {\n                    event = .modified\n                }\n                \n                await MainActor.run {\n                    onChange(event)\n                }\n            }\n        }\n        \n        source.setCancelHandler {\n            close(fd)\n        }\n        \n        source.resume()\n        \n        watchers[tokenId] = WatcherState(\n            fileDescriptor: fd,\n            source: source,\n            debounceTask: debounceTask\n        )\n        \n        return FileWatchToken(id: tokenId, url: url)\n    }\n    \n    func stopWatching(_ token: FileWatchToken) {\n        guard let state = watchers.removeValue(forKey: token.id) else { return }\n        state.debounceTask?.cancel()\n        state.source.cancel()\n    }\n}\n```\n\n## Usage in Editor\n\n```swift\n@Observable\nclass PromptEditorViewModel {\n    private var watchToken: FileWatchToken?\n    private let fileWatcher: FileWatching\n    \n    var showExternalChangeAlert = false\n    \n    func openPrompt(_ prompt: Prompt) {\n        // Start watching\n        watchToken = fileWatcher.watch(url: prompt.fileURL) { [weak self] event in\n            switch event {\n            case .modified:\n                self?.showExternalChangeAlert = true\n            case .deleted:\n                self?.handleExternalDeletion()\n            case .renamed:\n                self?.handleExternalRename()\n            }\n        }\n    }\n    \n    func closeEditor() {\n        if let token = watchToken {\n            fileWatcher.stopWatching(token)\n        }\n    }\n}\n```\n\n## Lifecycle Rules\n1. Start watching when prompt opens in editor\n2. Stop watching when editor closes\n3. One source per open file\n4. Clean up on app termination\n\n## Debouncing (Why 100ms?)\nEditors often do multiple writes in quick succession (save + backup + format):\n- Without debounce: multiple events fire, UI flickers\n- With 100ms debounce: coalesce into single event\n- 100ms is imperceptible to users but catches most rapid saves\n\n## Acceptance Criteria\n- [ ] Detects external modifications\n- [ ] Detects external deletions\n- [ ] Debounces rapid events (~100ms)\n- [ ] Callback fires on main thread\n- [ ] Properly cleans up file descriptors\n- [ ] Handles file not existing\n- [ ] Unit tests for event detection\n- [ ] Integration test with actual file modification\n\n## References\n- docs/plans/plan.md §5.4 FileWatcher\n- docs/plans/plan.md §2.4 External edits + conflicts\n- Apple: DispatchSource documentation","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-22T03:20:10.161640Z","created_by":"mjefferson","updated_at":"2026-01-22T03:20:10.162037Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-tsy","depends_on_id":"pho-3n0","type":"parent-child","created_at":"2026-01-22T03:20:10.162028Z","created_by":"mjefferson"}]}
{"id":"pho-uwb","title":"Create app icon and assets","description":"# Create App Icon and Assets\n\n## Overview\nDesign and add the app icon, menu bar icon, and any other required assets.\n\n## Deliverables\n\n### App Icon\n- **Source**: 1024x1024 PNG\n- **Required sizes**: 16, 32, 64, 128, 256, 512, 1024 (+ @2x variants)\n- **Location**: Assets.xcassets/AppIcon.appiconset\n\n### Menu Bar Icon\n- **Type**: Template image (single color, system adapts for light/dark)\n- **Sizes**: 18x18 (@1x) and 36x36 (@2x)\n- **Format**: PDF or PNG\n- **Location**: Assets.xcassets/MenuBarIcon.imageset\n\n## Design Direction\n- Should evoke \"collecting\" or \"organizing\" prompts\n- Consider: speech bubble, document stack, magnifying glass, bookmark\n- Must be recognizable at small sizes (16x16)\n- Works in both light and dark mode\n- Not too similar to existing apps (Notes, Reminders, etc.)\n\n## Technical Notes\n\n### Asset Catalog Setup\n```\nResources/\n└── Assets.xcassets/\n    ├── AppIcon.appiconset/\n    │   ├── Contents.json\n    │   └── [icon files]\n    └── MenuBarIcon.imageset/\n        ├── Contents.json\n        └── [icon files]\n```\n\n### Menu Bar Template Image\nFor the icon to adapt to system appearance:\n- Single color (black works)\n- Transparent background\n- Mark as template: NSImage.isTemplate = true\n- Or use PDF with \"Render As: Template Image\" in asset catalog\n\n## MVP vs Final\n- **MVP**: Can use placeholder (SF Symbol or simple shape)\n- **Final**: Custom-designed icon with professional polish\n\nSuggestion: Use SF Symbol `doc.text.magnifyingglass` for MVP menu bar icon.\n\n## Acceptance Criteria\n- [ ] App icon shows in Dock (when app is running)\n- [ ] App icon shows in Finder\n- [ ] Menu bar icon visible and recognizable\n- [ ] Works correctly in light mode\n- [ ] Works correctly in dark mode\n- [ ] No asset warnings in Xcode/build output\n\n## Future Polish (Not MVP)\n- Consider hiring designer for final icon\n- Animated menu bar icon states (searching, syncing)\n- Touch Bar icons (if supporting older Macs)","status":"open","priority":3,"issue_type":"task","created_at":"2026-01-22T03:17:21.699302Z","created_by":"mjefferson","updated_at":"2026-01-22T03:17:32.737671Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-uwb","depends_on_id":"pho-1zt","type":"parent-child","created_at":"2026-01-22T03:17:21.699698Z","created_by":"mjefferson"},{"issue_id":"pho-uwb","depends_on_id":"pho-3uh","type":"blocks","created_at":"2026-01-22T03:17:32.737661Z","created_by":"mjefferson"}]}
{"id":"pho-xai","title":"Phase 1.8: Polish and Release Prep","description":"# Phase 1.8: Polish and Release Prep\n\n## Overview\nFinal MVP polish: settings, onboarding, auto-updates, error handling, and performance verification before shipping.\n\n## Why This Matters (Strategic Context)\nThe difference between \"works\" and \"ships\" is polish:\n- First-run experience sets user expectations\n- Error handling builds trust (\"this app won't lose my data\")\n- Performance proves the value proposition\n- Auto-updates enable iteration post-launch\n\n**This is the gate before release.** Don't ship until this epic is done.\n\n## Key Deliverables\n\n### Settings View\n- **Vault location** (with migration helper)\n- **Appearance** (follows system / light / dark)\n- **Backup toggle** and configuration (last N backups)\n- **About** (version, update check, credits)\n- **Advanced** (rebuild index, reset to defaults)\n\n### Onboarding (First-Run)\n- Welcome screen explaining the app\n- Vault location selection (default or custom)\n- Optional: sample prompts to get started\n- Optional: quick tour of key features\n- Skip option for power users\n\n### Sparkle Auto-Updates\n- Integrate Sparkle framework\n- Configure appcast URL\n- Code signing setup (required for Sparkle)\n- Update check on launch (configurable frequency)\n- Manual \"Check for Updates\" in Help menu\n\n### Error Handling Polish\n- User-friendly error messages (not stack traces)\n- Toast/alert for transient operations\n- Structured logging for debugging (swift-log)\n- Crash reporting (optional, opt-in)\n\n### Performance Verification\nTest with realistic and stress workloads:\n\n| Scenario | Target | Measurement |\n|----------|--------|-------------|\n| 500 prompts | Search <200ms | Automated benchmark |\n| 5,000 prompts | Search <500ms | Stress test |\n| App launch | <1s to menu bar ready | Manual timing |\n| Vault scan | <2s incremental | Automated |\n| Memory usage | <100MB typical | Instruments |\n\n## Polish Checklist\n\n### Keyboard Shortcuts\n- [ ] All shortcuts documented in menus\n- [ ] No conflicts with system shortcuts\n- [ ] Cmd+, opens Settings\n- [ ] Cmd+Q quits cleanly\n\n### Accessibility\n- [ ] VoiceOver support for main flows\n- [ ] Sufficient color contrast\n- [ ] Focus indicators visible\n- [ ] Dynamic Type support (where applicable)\n\n### Visual Polish\n- [ ] Dark mode fully supported\n- [ ] Icons crisp at all sizes\n- [ ] No layout glitches on resize\n- [ ] Window state persists across launches\n\n### Edge Cases\n- [ ] Empty state (no prompts) looks good\n- [ ] Long titles truncate gracefully\n- [ ] Large prompts (10KB+) don't break UI\n- [ ] Offline mode works (no network needed)\n\n## Testing Requirements\n- Full regression test pass (all UI tests green)\n- Performance benchmarks documented\n- Manual QA checklist completed\n- Beta testing with real users (optional but recommended)\n\n## This Epic Requires\n- ALL other Phase 1 epics complete\n- This is the final gate before release\n\n## Release Checklist\n- [ ] All tests passing\n- [ ] No P0/P1 bugs open\n- [ ] Performance targets met\n- [ ] Code signed and notarized\n- [ ] Appcast configured\n- [ ] Landing page ready (optional)\n- [ ] README updated\n\n## References\n- docs/plans/plan.md §12 Success Metrics\n- docs/plans/plan.md §8 Testing Strategy","status":"open","priority":2,"issue_type":"epic","created_at":"2026-01-22T03:15:26.352867Z","created_by":"mjefferson","updated_at":"2026-01-22T03:15:38.411885Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-xai","depends_on_id":"pho-1nn","type":"blocks","created_at":"2026-01-22T03:15:38.367744Z","created_by":"mjefferson"},{"issue_id":"pho-xai","depends_on_id":"pho-1nr","type":"blocks","created_at":"2026-01-22T03:15:38.383920Z","created_by":"mjefferson"},{"issue_id":"pho-xai","depends_on_id":"pho-1qw","type":"parent-child","created_at":"2026-01-22T03:15:26.353236Z","created_by":"mjefferson"},{"issue_id":"pho-xai","depends_on_id":"pho-24o","type":"blocks","created_at":"2026-01-22T03:15:38.398190Z","created_by":"mjefferson"},{"issue_id":"pho-xai","depends_on_id":"pho-30e","type":"blocks","created_at":"2026-01-22T03:15:38.411871Z","created_by":"mjefferson"}]}
{"id":"pho-xrf","title":"Integrate Sparkle for auto-updates","description":"# Integrate Sparkle for Auto-Updates\n\n## Overview\nSet up Sparkle framework for automatic app updates.\n\n## Steps\n\n### 1. Add to App\n```swift\nimport Sparkle\n\n@main\nstruct PromptHoarderApp: App {\n    private let updaterController: SPUStandardUpdaterController\n    \n    init() {\n        updaterController = SPUStandardUpdaterController(\n            startingUpdater: true,\n            updaterDelegate: nil,\n            userDriverDelegate: nil\n        )\n    }\n    \n    var body: some Scene {\n        // ...\n        \n        Settings {\n            SettingsView(updater: updaterController.updater)\n        }\n        \n        // Add Check for Updates menu item\n        CommandGroup(after: .appInfo) {\n            CheckForUpdatesView(updater: updaterController.updater)\n        }\n    }\n}\n```\n\n### 2. Configure Appcast\n- Set up appcast.xml on server\n- Configure SUFeedURL in Info.plist\n\n### 3. Code Signing\n- Sign app with Developer ID\n- Notarize for Gatekeeper\n\n### 4. Update Check Options\n- Check on launch\n- Check interval (daily/weekly)\n- Manual check via menu\n\n## Acceptance Criteria\n- [ ] Sparkle initialized on launch\n- [ ] Check for Updates menu item works\n- [ ] Auto-check on launch (configurable)\n- [ ] App properly signed\n- [ ] Appcast URL configured","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:27:15.066942Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:15.067373Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-xrf","depends_on_id":"pho-xai","type":"parent-child","created_at":"2026-01-22T03:27:15.067360Z","created_by":"mjefferson"}]}
{"id":"pho-yxd","title":"Build WorkflowRunnerView","description":"# Build WorkflowRunnerView\n\n## Overview\nStep-by-step workflow execution: show each prompt, resolve variables, copy per step.\n\n## Key Features\n- Current step highlighting\n- Prompt preview with resolved variables\n- Copy button per step\n- Next/Previous navigation\n- Progress indicator (Step 2 of 5)\n\n## UX Flow\n1. User opens workflow runner\n2. Step 1 shown with prompt preview\n3. Fill variables if needed\n4. Copy button copies resolved prompt\n5. Click Next to advance\n6. Repeat until done\n\n## Implementation\n```swift\nstruct WorkflowRunnerView: View {\n    let workflow: Workflow\n    @State private var currentStepIndex = 0\n    @State private var variableValues: [UUID: [String: String]] = [:]  // Per-step\n    \n    var currentStep: WorkflowStep {\n        workflow.steps[currentStepIndex]\n    }\n    \n    var body: some View {\n        VStack {\n            // Progress\n            Text(\"Step \\(currentStepIndex + 1) of \\(workflow.steps.count)\")\n            ProgressView(value: Double(currentStepIndex + 1), total: Double(workflow.steps.count))\n            \n            // Prompt preview\n            // Variable form (if needed)\n            // Copy button\n            \n            // Navigation\n            HStack {\n                Button(\"Previous\") { currentStepIndex -= 1 }\n                    .disabled(currentStepIndex == 0)\n                Button(\"Next\") { currentStepIndex += 1 }\n                    .disabled(currentStepIndex == workflow.steps.count - 1)\n            }\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Shows correct step content\n- [ ] Progress indicator accurate\n- [ ] Variables resolved per step\n- [ ] Copy works per step\n- [ ] Navigation works\n- [ ] Remembers variable values during session","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:27:14.979335Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:26.745980Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-yxd","depends_on_id":"pho-1nn","type":"parent-child","created_at":"2026-01-22T03:27:14.979701Z","created_by":"mjefferson"},{"issue_id":"pho-yxd","depends_on_id":"pho-3g6","type":"blocks","created_at":"2026-01-22T03:27:26.745967Z","created_by":"mjefferson"}]}
{"id":"pho-zwu","title":"Build Export UI with progress","description":"# Build Export UI with Progress\n\n## Overview\nSave panel for export, progress for full library export.\n\n## Single Prompt Export\n```swift\nfunc exportPrompt(_ prompt: Prompt) {\n    let panel = NSSavePanel()\n    panel.nameFieldStringValue = \"\\(prompt.title).md\"\n    panel.allowedContentTypes = [.init(filenameExtension: \"md\")!]\n    \n    if panel.runModal() == .OK, let url = panel.url {\n        Task {\n            try await exportService.exportPrompt(prompt, to: url)\n        }\n    }\n}\n```\n\n## Full Library Export\n```swift\nfunc exportLibrary() {\n    let panel = NSSavePanel()\n    panel.nameFieldStringValue = \"PromptHoarder-Export-\\(Date().formatted(date: .numeric, time: .omitted)).zip\"\n    panel.allowedContentTypes = [.zip]\n    \n    if panel.runModal() == .OK, let url = panel.url {\n        showExportProgress = true\n        \n        Task {\n            try await exportService.exportLibrary(to: url) { progress in\n                await MainActor.run {\n                    exportProgress = progress\n                }\n            }\n            showExportProgress = false\n        }\n    }\n}\n```\n\n## Acceptance Criteria\n- [ ] Single prompt export works\n- [ ] Library export creates ZIP\n- [ ] Progress shown during export\n- [ ] Can cancel export (optional)\n- [ ] Success message shown","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-22T03:27:15.024631Z","created_by":"mjefferson","updated_at":"2026-01-22T03:27:26.766519Z","compaction_level":0,"original_size":0,"dependencies":[{"issue_id":"pho-zwu","depends_on_id":"pho-1nr","type":"parent-child","created_at":"2026-01-22T03:27:15.024998Z","created_by":"mjefferson"},{"issue_id":"pho-zwu","depends_on_id":"pho-2cc","type":"blocks","created_at":"2026-01-22T03:27:26.766506Z","created_by":"mjefferson"}]}
